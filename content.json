{"meta":{"title":"高登的个人博客","subtitle":"各人下雪，各人有各人的隐晦与皎洁","description":"感受春日夏风秋叶冬雪，去看南水北山东麓西岭","author":"高登","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-12-14T03:11:36.553Z","updated":"2019-12-14T03:11:36.553Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":"404"},{"title":"关于","date":"2019-11-11T18:14:14.000Z","updated":"2020-01-04T10:28:52.179Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我，儒雅随和。"},{"title":"文章分类","date":"2018-10-15T00:03:57.000Z","updated":"2019-12-14T03:10:31.402Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-14T11:35:42.000Z","updated":"2019-12-14T03:09:57.681Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ElasticSearch7.6.x API操作详解","slug":"ElasticSearch7.6.x API操作详解","date":"2021-02-07T00:00:00.000Z","updated":"2021-02-09T06:54:20.556Z","comments":true,"path":"2021/02/07/ElasticSearch7.6.x API操作详解/","link":"","permalink":"http://yoursite.com/2021/02/07/ElasticSearch7.6.x%20API%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/","excerpt":"Test 类","text":"Test 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183package com.zhuang.zhuangesapi;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializeFilter;import com.zhuang.zhuangesapi.pojo.User;import org.apache.lucene.util.QueryBuilder;import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;import org.elasticsearch.action.bulk.BulkRequest;import org.elasticsearch.action.bulk.BulkResponse;import org.elasticsearch.action.delete.DeleteRequest;import org.elasticsearch.action.delete.DeleteResponse;import org.elasticsearch.action.get.GetRequest;import org.elasticsearch.action.get.GetResponse;import org.elasticsearch.action.index.IndexRequest;import org.elasticsearch.action.index.IndexResponse;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.action.support.master.AcknowledgedResponse;import org.elasticsearch.action.update.UpdateRequest;import org.elasticsearch.action.update.UpdateResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.client.indices.CreateIndexRequest;import org.elasticsearch.client.indices.CreateIndexResponse;import org.elasticsearch.client.indices.GetIndexRequest;import org.elasticsearch.common.unit.TimeValue;import org.elasticsearch.common.xcontent.XContentType;import org.elasticsearch.index.query.MatchAllQueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.index.query.TermQueryBuilder;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.util.ArrayList;import java.util.concurrent.TimeUnit;@SpringBootTestpublic class ElasticSearchClientConfigTest &#123; @Autowired @Qualifier(\"restHighLevelClient\") private RestHighLevelClient client; //索引的创建 @Test void testCreateIndex() throws IOException &#123; //创建索引请求 CreateIndexRequest request=new CreateIndexRequest(\"kuang_index\"); //客户端执行请求IndicesClient,请求后获得响应 CreateIndexResponse createIndexResponse= client.indices().create(request, RequestOptions.DEFAULT); System.out.println(createIndexResponse); &#125; //测试获取索引 @Test void testExisIndex() throws IOException &#123; GetIndexRequest request = new GetIndexRequest(\"kuang_index\"); boolean exists = client.indices().exists(request,RequestOptions.DEFAULT); System.out.println(exists); &#125; @Test void testDeleteIndex() throws IOException &#123; DeleteIndexRequest request = new DeleteIndexRequest(\"kuang_index\"); AcknowledgedResponse delete =client.indices().delete(request,RequestOptions.DEFAULT); System.out.println(delete.isAcknowledged()); &#125; //测试添加文档 @Test void testAddDocument() throws IOException &#123; //创建对象 User user = new User(\"狂神说\",3); /* 创建请求 */ IndexRequest request = new IndexRequest(\"kuang_index\"); //规则 put /kuang_index/doc/1 request.id(\"1\"); request.timeout(TimeValue.timeValueSeconds(1)); request.timeout(\"1s\"); //将数据放入请求 json request.source(JSON.toJSONString(user), XContentType.JSON); //客户端发送请求，获取响应结果 IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT); System.out.println(indexResponse.toString()); System.out.println(indexResponse.status()); &#125; //获取文档 @Test void testIsExists() throws IOException &#123; GetRequest getRequest = new GetRequest(\"kuang_index\", \"1\"); GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT); System.out.println(getResponse.getSourceAsString());//打印文档内容 System.out.println(getResponse); &#125; //更新文档的信息 @Test void testUpdateRequest() throws IOException &#123; UpdateRequest updateRequest = new UpdateRequest(\"kuang_index\", \"1\"); updateRequest.timeout(\"1s\"); User user = new User(\"狂神说Java\", 18); updateRequest.doc(JSON.toJSONString(user),XContentType.JSON); UpdateResponse updateResponse = client.update(updateRequest, RequestOptions.DEFAULT); System.out.println(updateResponse.status()); &#125; //删除文档记录 @Test void testDeleteRequest() throws IOException &#123; DeleteRequest request = new DeleteRequest(\"kuang_index\", \"1\"); request.timeout(\"1s\"); DeleteResponse deleteResponse = client.delete(request, RequestOptions.DEFAULT); System.out.println(deleteResponse.status()); &#125; //特殊 批量插入 @Test void testBulkRequest() throws IOException&#123; BulkRequest bulkRequest = new BulkRequest(); bulkRequest.timeout(\"10s\"); ArrayList&lt;Object&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(\"kuangshen1\",3)); userList.add(new User(\"kuangshen2\",3)); userList.add(new User(\"kuangshen3\",3)); userList.add(new User(\"kuangshen4\",3)); //批量处理请求 for (int i = 0; i &lt;userList.size() ; i++) &#123; //批量更新和批量删除，就在这里秀爱第一请求就可以了 bulkRequest.add( new IndexRequest(\"kuang_index\") .id(\"\"+(i+1)) .source(JSON.toJSONString(userList.get(i)),XContentType.JSON)); BulkResponse bulkResponse = client.bulk(bulkRequest,RequestOptions.DEFAULT); System.out.println(bulkResponse.hasFailures());//是否失败，返回 false b表示成功 &#125; &#125; //查询 //SearchRequest 搜索请求 //SearchSourceBuilder 条件构造 //HighlightBuilder 构建高亮 //TermQueryBuilder 精确查询 // MatchAllQueryBuilder 匹配全部 // xxx QueryBuilder @Test void testSearch() throws IOException &#123; SearchRequest searchRequest = new SearchRequest(\"kuang_index\"); //构建搜索条件 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();//封装构建 //查询条件，可以用QueryBuilders 工具来实现 //QueryBulider.termQuery 精确 //QueryBuliders.matchAllQuery() 匹配所有 TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(\"name\", \"qinjiang1\");// MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery(); sourceBuilder.query(termQueryBuilder);//精确 sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); searchRequest.source(sourceBuilder); //执行请求 SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT); System.out.println(JSON.toJSONString(searchResponse.getHits())); System.out.println(\"==========\"); for (SearchHit documentFields : searchResponse.getHits().getHits()) &#123; System.out.println(documentFields.getSourceAsString()); &#125; &#125;&#125; Config 类1234567891011121314151617181920package com.zhuang.zhuangesapi.config;import org.apache.http.HttpHost;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class ElasticSearchClientConfig &#123; @Bean RestHighLevelClient restHighLevelClient()&#123; RestHighLevelClient client = new RestHighLevelClient( RestClient.builder( new HttpHost(&quot;127.0.0.1&quot;,9200,&quot;http&quot;) ) ); return client; &#125;&#125;","categories":[],"tags":[{"name":"学习 ES","slug":"学习-ES","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0-ES/"}]},{"title":"linux常用命令","slug":"Linux操作命令","date":"2021-02-01T13:29:19.000Z","updated":"2021-02-09T06:54:54.813Z","comments":true,"path":"2021/02/01/Linux操作命令/","link":"","permalink":"http://yoursite.com/2021/02/01/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/","excerpt":"linux常用命令","text":"linux常用命令 1、cd命令 这是一个非常基本，也是大家经常需要使用的命令，它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。如： 123cd /root/Docements # 切换到目录/root/Docementscd ./path # 切换到当前目录下的path目录中，“.”表示当前目录 cd ../path # 切换到上层目录中的path目录中，“..”表示上一层目录 2、ls命令 这是一个非常有用的查看文件与目录的命令，list之意，它的参数非常多，下面就列出一些我常用的参数吧，如下： 12345-l ：列出长数据串，包含文件的属性与权限数据等-a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）-d ：仅列出目录本身，而不是列出目录的文件数据-h ：将文件容量以较易读的方式（GB，kB等）列出来-R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来 3、grep命令 该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，它的简单语法为 1grep [-acinv] [--color=auto] &apos;查找字符串&apos; filename 4、find命令 find是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多，所以在这里将给把它们分类列出，它的基本语法如下： 1234567891011121314151617181920212223242526find [PATH] [option] [action]# 与时间有关的参数：-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；-newer file : 列出比file还要新的文件名# 例如：find /root -mtime 0# 在当前目录下查找今天之内有改动的文件# 与用户或用户组名有关的参数：-user name : 列出文件所有者为name的文件-group name : 列出文件所属用户组为name的文件-uid n : 列出文件所有者为用户ID为n的文件-gid n : 列出文件所属用户组为用户组ID为n的文件# 例如：find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件# 与文件权限及名称有关的参数：-name filename ：找出文件名为filename的文件-size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件-tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；-perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755；-perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示-perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示# 例如：find / -name passwd # 查找文件名为passwd的文件find . -perm 0755 # 查找当前目录中文件权限的0755的文件find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte 5、cp命令 该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下，它的常用参数如下： 12345-a ：将文件的特性一起复制-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行-r ：递归持续复制，用于目录的复制行为-u ：目标文件与源文件有差异时才会复制 6、mv命令 该命令用于移动文件、目录或更名，move之意，它的常用参数如下： 123-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i ：若目标文件已经存在，就会询问是否覆盖-u ：若目标文件已经存在，且比目标文件新，才会更新 注：该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”。 例如： 12mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中mv file1 file2 # 把文件file1重命名为file2 7、rm命令 该命令用于删除文件或目录，remove之间，它的常用参数如下： 123-f ：就是force的意思，忽略不存在的文件，不会出现警告消息-i ：互动模式，在删除前会询问用户是否操作-r ：递归删除，最常用于目录删除，它是一个非常危险的参数 例如： 12rm -i file # 删除文件file，在删除之前会询问是否进行该操作rm -fr dir # 强制删除目录dir中的所有文件 8、ps命令 该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下： 12345-A ：所有的进程均显示出来-a ：不与terminal有关的所有进程-u ：有效用户的相关进程-x ：一般与a参数一起使用，可列出较完整的信息-l ：较长，较详细地将PID的信息列出 其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下： 12345ps aux # 查看系统所有的进程数据ps ax # 查看不与terminal有关的所有进程ps -lA # 查看系统所有的进程数据ps axjf # 查看连同一部分进程树状态ps -ef|grep tomcat #查看tomcat运行状态 9、kill命令 该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下： 12kill -signal PIDkill -9 pid #一般配合ps命令使用杀tomcat进程，起到关闭tomcat作用。 signal的常用参数如下：注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。 123451：SIGHUP，启动被终止的进程2：SIGINT，相当于输入ctrl+c，中断一个程序的进行9：SIGKILL，强制中断一个进程的进行15：SIGTERM，以正常的结束进程方式来终止进程17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行 例如： 123# 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程kill -SIGTERM %1 # 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得kill -SIGHUP PID 10、killall命令 该命令用于向一个命令启动的进程发送一个信号，它的一般语法如下： 1killall [-iIe] [command name] 它的参数如下： 12345-i ：交互式的意思，若需要删除时，会询问用户-e ：表示后面接的command name要一致，但command name不能超过15个字符-I ：命令名称忽略大小写# 例如：killall -SIGHUP syslogd # 重新启动syslogd 11、file命令 该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了，它的用法非常简单，基本语法如下： 123file filename#例如：file ./test 12、tar命令 该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下： 12345678-c ：新建打包文件-t ：查看打包文件的内容含有哪些文件名-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中-j ：通过bzip2的支持进行压缩/解压缩-z ：通过gzip的支持进行压缩/解压缩-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来-f filename ：filename为要处理的文件-C dir ：指定压缩/解压缩的目录dir 上面的解说可以已经让你晕过去了，但是通常我们只需要记住下面三条命令即可： 123压缩：tar -zcvf filename.tar 要被处理的文件或目录名称查询：tar -ztvf filename.tar解压：tar -zxvf filename.tar -C 欲解压缩的目录 注：这里只适用于后缀.tar压缩文件，后缀为zip的压缩文件直接使用unzip进行解压。 13、cat命令 该命令用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据。例如： 12cat text | less # 查看text文件中的内容# 注：这条命令也可以使用less text来代替 14、chgrp命令 该命令用于改变文件所属用户组，它的使用非常简单，它的基本用法如下： 1234chgrp [-R] dirname/filename-R ：进行递归的持续对所有文件和子目录更改# 例如：chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users 15、chmod命令 该命令用于改变文件的权限，一般的用法如下： 12chmod [-R] xyz 文件或目录-R：进行递归的持续更改，即连同子目录下的所有文件都会更改 同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改。 123# 例如：chmod 0755 file # 把file的文件权限改变为-rxwr-xr-xchmod g+w file # 向file的文件权限中加入用户组可写权 16、 vim命令 该命令主要用于文本编辑，它接一个或多个文件名作为参数，如果文件存在就打开，如果文件不存在就以该文件名创建一个文件。vim是一个非常好用的文本编辑器，它里面有很多非常好用的命令，在这里不再多说。部分服务器没有vim命令也可以用vi命令代替，或者自行下周vim命令。 17、time命令 该命令用于测算一个命令（即程序）的执行时间。它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个time即可，例如： 1time ./processtime ps aux","categories":[],"tags":[{"name":"学习 Linux","slug":"学习-Linux","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0-Linux/"}]},{"title":"毕设说","slug":"毕设说","date":"2021-01-07T17:13:50.674Z","updated":"2021-01-09T04:54:57.624Z","comments":true,"path":"2021/01/08/毕设说/","link":"","permalink":"http://yoursite.com/2021/01/08/%E6%AF%95%E8%AE%BE%E8%AF%B4/","excerpt":"毕设说","text":"毕设说 尊敬的老师下午好： 我是17计算机一班的梁庄杰，我的毕设项目题目是 基于SpringBoot+Vue音乐网站设计与实现 。因为这一个多月我都在公司java开发实习，暂时只完成了后端代码与前端的后台，前台系统暂时还没有完善好。首先我来介绍下项目的开发环境。这款项目是由windows系统开发，jdk的版本是1.8，mysql版本是8.0。开发软件主要用了idea2020.3、Visual、SQLyoung。 然后来看一下后端项目的构建，先看一下数据库的表。collect是所有数据的汇总，comment是歌曲评论。consumer是用户表。rank表也是一个汇总表。然后看一下项目结构，java文件用来存放Java源码，包括程序的入口。resources用来存放静态资源。 然后看下配置文件，application.properties 文件，用于连接数据库。generatorConfig.xml利用MyBatis Generator 自动生成代码（实体类，Mapper接口和Mapper.xml文件），需要指定mysql-connector-java （ src/main/resources 目录下）和生成文件的路径。在 src/main/resources目录下创建 generatorConfig.xml 文件并配置。pom.xml 文件负责配置项目相关的依赖和插件。开发接口实体类（domain 目录下）定义数据库表所对应的实体类。Mapper 层 / DAO 层（dao、mapper 目录下）数据操作层：向数据库发送 SQL 语句，完成数据库操作。分为 Mapper 接口 和 Mapper 接口映射文件。Service 层：服务层：完成业务逻辑处理。调用 Mapper 层操作数据库。分为 Service 接口 + Service 实现，用面向接口的编程思想，方便后续功能的解藕及扩展。Controller 层，控制层：对请求和响应进行控制，调用 Service 层进行业务逻辑处理，最后将处理好的数据返回给前端。 最后总结一下：当前端要访问数据的时候后端就提供相应接口，接口的编写是通过 Controller 层监听请求， 数据的处理交给 Service 层，而 Service 层再通过 Mapper 层操作数据库，操作完成后数据再一层层往上走，最后返回给前端。 最终项目结构12345678910111213141516171819202122232425262728├── avatorImages // 用户头像├── img│ ├── singerPic // 歌手图片│ ├── songListPic // 歌单图片│ └── songPic // 歌曲图片├── song // 存放歌曲├── src│ ├── main│ │ ├── java│ │ │ └── com.example.demo│ │ │ ├── config // 配置（跨域）│ │ │ ├── controller // 控制层，接收请求返回响应│ │ │ ├── dao // 数据操作层│ │ │ ├── domain // 实体类│ │ │ ├── service│ │ │ │ └── impl // Service 层的接口│ │ │ └── HwMusicApplicationTests.java // 项目入口│ │ └── resources│ │ ├── mapper // mapper.xml文件，操作数据库│ │ ├── static // 存放静态资源│ │ ├── templates│ │ ├── application.properties // 连接数据库│ │ └── generatorConfig.xml // MyBatis Generator 自动生成代码│ └── test│ └── java│ └── com.example.demo // 测试用的├── pom.xml // 添加相关依赖和插件└── target 客户端项目的构建：1、创建项目这里项目的创建比后端要简单的多，直接用官方提供的脚手架，安装 vue，创建项目，然后npm install安装项目依赖，npm run dev命令就让项目跑起来。 开发思路： 因为代码都放在一起对后期维护和修改都不方便，所以把他们根据功能或者位置拆分开，放到 components 文件夹下面去实现，最后再整合到 views 文件夹下。加载到 App.vue 文件中，最后渲染到页面中。 123456789101112131415161718192021222324252627282930├── build //webpack相关配置文件├── config // vue基本配置文件├── node_modules // 包├── index.html // 入口页面├── package.json // 管理包的依赖├── src // 项目源码目录│ ├── App.vue // 根组件│ ├── main.js //入口js文件│ ├── api // 封装请求的 api│ ├── assets // 静态资源，图片、js、css 等│ ├── mixins // 公共方法│ ├── components│ │ ├── TheHeader.vue //展示头部│ │ ├── Home.vue //展示主页面│ │ ├── Sidebar.vue //展示页面侧面│ │ └── SongAudio.vue //歌曲音频│ ├── pages│ │ ├── CollectPage.vue //收藏页 │ │ ├── CommentPage.vue //评论页│ │ ├── ConsumerPage.vue //用户管理页│ │ ├── InfoPage.vue //信息页(系统主页)│ │ ├── ListSongPage.vue //http://localhost:8080/#/ListSong?id=1│ │ ├── Login.vue //登录页面│ │ ├── SingerPage.vue //歌手管理页面│ │ ├── SongListPage.vue //歌单管理│ │ └── SongPage.vue //歌手管理中的歌曲管理页│ ├── router// 路由│ └── store // 管理数据├── static // 存放静态资源 └── test // 测试文件目录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647├── build // webpack相关配置文件├── config // vue基本配置文件├── node_modules // 包├── index.html // 入口页面├── package.json // 管理包的依赖├── src // 项目源码目录│ ├── assets // 静态资源，图片、js、css 等│ ├── api // 封装请求的 api│ ├── mixins // 公共方法│ ├── router // 路由│ ├── store // 管理数据│ ├── components│ │ ├── AlbumContent.vue // 展示歌单歌手包含的歌曲│ │ ├── Comment.vue // 评论│ │ ├── ContentList.vue // 展示歌单歌手区│ │ ├── LoginLogo.vue // 登录界面的logo│ │ ├── PlayBar.vue // 页面底部的播放控制区│ │ ├── ScrollTop.vue // 回到顶部│ │ ├── SongAudio.vue // 接收音乐并播放的位置│ │ ├── Swiper.vue // 轮播图│ │ ├── TheFooter.vue // 页脚│ │ ├── TheHeader.vue // 页头│ │ ├── TheAside.vue // 播放列表│ │ ├── Upload.vue // 修改头像│ │ ├── Info.vue // 个人信息区│ │ └── search // 搜索区│ │ ├── SearchSongLists.vue // 按歌单搜索│ │ └── SearchSongs.vue // 按歌手搜索│ ├── pages // 组件│ │ ├── 404.vue // 404│ │ ├── Home.vue // 首页│ │ ├── Setting.vue // 设置│ │ ├── Login.vue // 登录区│ │ ├── LoginUp.vue // 注册区│ │ ├── Lyric.vue // 歌词显示区│ │ ├── MyMusic.vue // 我的收藏区│ │ ├── Search.vue // 搜索区│ │ ├── Singer.vue // 歌手区│ │ ├── SingerAlbum.vue // 歌手详情│ │ ├── SongList.vue // 歌单区│ │ └── SongListAlbum.vue // 歌单详情│ ├── main.js // 入口js文件│ └── App.vue // 根组件├── static // 存放静态资源 ├── test // 测试文件目录├── .babelrc // bable 编译配置└── .gitignore // 提交忽略的文件配置 tip：跨域问题： config @Configurationconsumerpage:用户管理inforpage:系统首页 添加功能：弹出 提交 查询：后台写查询方法，只需要在前端的src/api/index写接口，然后在singerpage调用方法，在第9行 el-table设置查询前段格式。把图片放到cooker缓存里面，这是vue的一个非常重要的机制，在src/store/index.js中缓存，export default store导出去， mixinx/index接收 mixinx/index是一个公共类，第10行getUrl根据相对地址获取绝对路径。最后在museic-server/src/controller/SongListController中查询图片地址导入mixin，所以mixinx/index中所有方法都可以用在src/mixins中44h行判断性别 根据搜索框搜索：在watch监控值的变化，发生变化后执行代码。 分页：在每个vue文件中的computed中计算表的数据，pagination是分页的配置属性methods获取当前页 歌曲管理：新创一个songpage类，用click点击事件点击转向，在router/index设置转向的页面。 歌曲管理前端：ListSongPage页面 通过getData查询的时候会通过116行songid查询个歌单下面的所有歌单列表，进行了一个转换，获取每一个歌曲的数据。（就是数据库songlist表的songid查询 song表中的数据，传入到110 111行的tbaledate和tempdata中，124行getsong方法从后台查询，api/index中songofsingerid）。 用户管理：添加新用户的表单验证consumerpage 273行 rules方法（trigger: ‘blur’ 失去焦点） 371行中必须不为空 系统首页：78行 从api/index中获取数据。InfoPage83行返回数据。饼图：获取consumer后可以通过幻术setSex获取用户数，最后从methods调用数据。柱状图","categories":[],"tags":[]},{"title":"面试题","slug":"HashMap底层原理","date":"2020-12-07T14:49:30.000Z","updated":"2020-12-08T05:37:24.810Z","comments":true,"path":"2020/12/07/HashMap底层原理/","link":"","permalink":"http://yoursite.com/2020/12/07/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","excerpt":"","text":"基础与语法##String类的常用方法有哪些？","categories":[],"tags":[]},{"title":"Spring","slug":"Spring","date":"2020-11-28T14:53:04.000Z","updated":"2020-11-30T03:06:59.124Z","comments":true,"path":"2020/11/28/Spring/","link":"","permalink":"http://yoursite.com/2020/11/28/Spring/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"复习","slug":"复习","date":"2020-11-26T09:38:32.000Z","updated":"2020-11-30T16:05:15.496Z","comments":true,"path":"2020/11/26/复习/","link":"","permalink":"http://yoursite.com/2020/11/26/%E5%A4%8D%E4%B9%A0/","excerpt":"此篇作为面试题的复习","text":"此篇作为面试题的复习 String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?可变性 简单的来说：String 类中使⽤ final 关键字修饰字符数组来保存字符串， private final charvalue[] ，所以 String 对象是不可变的。 ⽽ StringBuilder 与 StringBuffer 都继承⾃ AbstractStringBuilder 类，在AbstractStringBuilder 中也是使⽤字符数组保存字符串 char[]value 但是没有⽤ final 关键字修饰，所以这两种对象都是可变的。 相同情况下使⽤ StringBuilder 相⽐使⽤ StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的⻛险。 对于三者使⽤的总结 ：* 操作少量的数据: 适⽤ String 单线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder 多线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer 2 == 与 equals== : 它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(基本数据类型，==⽐的是值，引⽤数据类型==⽐的是内存地址)。equals() : 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：情况 1：类没有覆盖 equals() ⽅法。则通过 equals() ⽐᫾该类的两个对象时，等价于通过“==”比较这两个对象。情况 2：类覆盖了 equals() ⽅法。⼀般，我们都覆盖 equals() ⽅法来⽐᫾两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。举个例子 1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String(&quot;ab&quot;); // a 为⼀个引⽤ String b = new String(&quot;ab&quot;); // b为另⼀个引⽤,对象的内容⼀样 String aa = &quot;ab&quot;; // 放在常量池中 String bb = &quot;ab&quot;; // 从常量池中查找 if (aa WX bb) // true System.out.println(&quot;aaWXbb&quot;); if (a WX b) // false，⾮同⼀对象 System.out.println(&quot;aWXb&quot;); if (a.equals(b)) // true System.out.println(&quot;aEQb&quot;); if (42 WX 42.0) &#123; // true System.out.println(&quot;true&quot;); &#125; &#125; &#125; hashCode（）介绍 hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java中的任何类都包含有 hashCode() 函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利⽤到了散列码！（可以快速找到所需要的对象） hashCode() 的作⽤就是获取哈希码，也称为散列码；它实际上是返回⼀个 int整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode() 在散列表中才有⽤，在其它情况下没⽤。在散列表中 hashCode() 的作⽤是获取对象的散列码，进⽽确定该对象在散列表中的位置。 简述线程、程序、进程的基本概念 进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是动态的。系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。 程序是含有指令和数据的⽂件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。 线程与进程相似，但线程是⼀个⽐进程更⼩的执⾏单位。⼀个进程在其执⾏的过程中可以产⽣多个线程。 Java 中 IO 流分为⼏种? 按照流的流向分，可以分为输⼊流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的⻆⾊划分为节点流和处理流。 InputStream/Reader: 所有的输⼊流的基类，前者是字节输⼊流，后者是字符输⼊流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 既然有了字节流,为什么还要有字符流?字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是⾮常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就⼲脆提供了⼀个直接操作字符的接⼝，⽅便我们平时对字符进⾏流操作。如果⾳频⽂件、图⽚等媒体⽂件⽤字节流比较好，如果涉及到字符的话使⽤字符流比较好。 说说List,Set,Map三者的区别？ List(对付顺序的好帮⼿)： List接⼝存储⼀组不唯⼀（可以有多个元素引⽤相同的对象），有序的对象 Set(注重独⼀⽆⼆的性质): 不允许重复的集合。不会有多个元素引⽤相同的对象。 Map(⽤Key来搜索的专家): 使⽤键值对存储。Map会维护与Key有关联的值。两个Key可以引⽤相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。 Arraylist 与 LinkedList 区别? 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全； 底层数据结构： Arraylist 底层使⽤的是 Object 数组； LinkedList 底层使⽤的是 双向链表 数据结构 插⼊和删除是否受元素位置的影响： ① ArrayList 采⽤数组存储，所以插⼊和删除元素的时间复杂度受元素位置的影响。 LinkedList 采⽤链表存储，所以对于 add(E e) ⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置 i 插⼊和删除元素的话（ (add(int index, E element) ） 时间复杂度近似为 o(n)) 因为需要先移动到指定位置再插⼊。 #{}和${}的区别是什么？ ${} 是 Properties ⽂件中的变量占位符，它可以⽤于标签属性值和 sql 内部，属于静态⽂本替换，⽐如${driver}会被静态替换为 com.mysql.jdbc.Driver 。 #{} 是 sql 的参数占位符，Mybatis 会将 sql 中的 #{} 替换为?号，在 sql 执⾏前会使⽤PreparedStatement 的参数设置⽅法，按序给 sql 的?号占位符设置参数值，⽐如ps.setInt(0, parameterValue)， #{item.name} 的取值⽅式为使⽤反射从参数对象中获取item 对象的 name 属性值，相当于 param.getItem().getName() 。 #{}是预编译处理，${}是字符串替换 关于 JVM JDK 和 JRE 最详细通俗的解答JVM Java 虚拟机（JVM）是运⾏ Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），⽬的是使⽤相同的字节码，它们都会给出相同的结果。 什么是字节码?采⽤字节码的好处是什么? 在 Java 中，JVM 可以理解的代码就叫做 字节码 （即扩展名为 .class 的⽂件），它不⾯向任何特定的处理器，只⾯向虚拟机。Java 语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时⼜保留了解释型语⾔可移植的特点。所以 Java 程序运⾏时比较⾼效，⽽且，由于字节码并不针对⼀种特定的机器，因此，Java 程序⽆须重新编译便可在多种不同操作系统的计算机上运⾏。 Java 程序从源代码到运⾏⼀般有下⾯ 3 步：.java文件（源代码）====（JDK中的javac编译）====&gt;.class文件（JVM可理解的Java字节）=====JVM=====&gt;机器可执行的二进制机器码 总结:Java 虚拟机（JVM）是运⾏ Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），⽬的是使⽤相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语⾔“⼀次编译，随处可以运⾏”的关键所在。 JDK 和 JREJDK 是 Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。 JRE 是 Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。 多线程进程：进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是动态的。系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。线程线程与进程相似，但线程是⼀个⽐进程更⼩的执⾏单位。⼀个进程在其执⾏的过程中可以产⽣多个线程。二者关系：线程 是 进程 划分成的更⼩的运⾏单位。线程和进程最⼤的不同在于基本上各进程是独⽴的，⽽各线程则不⼀定，因为同⼀进程中的线程极有可能会相互影响。线程执⾏开销⼩，但不利于资源的管理和保护；⽽进程正相反 为什么要使⽤多线程呢? 从当代互联⽹发展趋势来说： 现在的系统动不动就要求百万级甚⾄千万级的并发量，⽽多线程并发编程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能⼒以及性能。 从计算机底层来说： 线程可以⽐作是轻量级的进程，是程序执⾏的最⼩单位,线程间的切换和调度的成本远远⼩于进程。另外，多核 CPU 时代意味着多个线程可以同时运⾏，这减少了线程上下⽂切换的开销。 多核时代： 多核时代多线程主要是为了提⾼ CPU 利⽤率。举个例⼦：假如我们要计算⼀个复杂的任务，我们只⽤⼀个线程的话，CPU 只会⼀个 CPU 核⼼被利⽤到，⽽创建多个线程就可以让多个 CPU 核⼼被利⽤到，这样就提⾼了 CPU 的利⽤率。 单核时代： 在单核时代多线程主要是为了提⾼ CPU 和 IO 设备的综合利⽤率。举个例⼦：当只有⼀个线程的时候会导致 CPU 计算时，IO 设备空闲；进⾏ IO 操作时，CPU 空闲。我们可以简单地说这两者的利⽤率⽬前都是 50%左右。但是当有两个线程的时候就不⼀样了，当⼀个线程执⾏ CPU 计算时，另外⼀个线程可以进⾏ IO 操作，这样两个的利⽤率就可以在理想情况下达到100%了。 什么是上下⽂切换?当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是⼀次上下⽂切换。 认识线程死锁线程死锁描述的是这样⼀种情况：多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。 说说线程的⽣命周期和状态? 状态名称 说明 NEW 初始状态 RUNNABLE 运行状态 BLOCKED 阻塞状态 WAITING 等待状态 TIME_WAITING 超时等待状态 TERMINATED 终止状态 数据库什么是MySQL?MySQL 是⼀种关系型数据库，在Java企业级开发中⾮常常⽤，MySQL的默认端⼝号是3306。 存储引擎⼀些常⽤命令查看MySQL提供的所有存储引擎 mysql&gt; show engines;查看MySQL当前默认的存储引擎 mysql&gt; show variables like ‘%storage_engine%’;查看表的存储引擎 show table status like “table_name” ;开启事务 mysql&gt; begin; | start transactions;终止事务 mysql&gt; commit; | rollback; 字符集及校对规则字符集指的是⼀种从⼆进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。MySQL中每⼀种字符集都会对应⼀系列的校对规则。 索引MySQL索引使⽤的数据结构主要有BTree索引 和 哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝⼤多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余⼤部分场景，建议选择BTree索引。 什么是事务?事务是逻辑上的⼀组操作，要么都执⾏，要么都不执⾏。(比如银行转账) 事物的四⼤特性 原⼦性（Atomicity）： 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要么完全不起作⽤； ⼀致性（Consistency）： 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的； 隔离性（Isolation）： 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的； 持久性（Durability）： ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。 并发事务带来哪些问题? 脏读（Dirty read）: 当⼀个事务正在访问数据并且对数据进⾏了修改，⽽这种修改还没有提交到数据库中，这时另外⼀个事务也访问了这个数据，然后使⽤了这个数据。因为这个数据是还没有提交的数据，那么另外⼀个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 丢失修改（Lost to modify）: 指在⼀个事务读取⼀个数据时，另外⼀个事务也访问了该数据，那么在第⼀个事务中修改了这个数据后，第⼆个事务也修改了这个数据。这样第⼀个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。 不可重复读（Unrepeatableread）: 指在⼀个事务内多次读同⼀数据。在这个事务还没有结束时，另⼀个事务也访问该数据。那么，在第⼀个事务中的两次读数据之间，由于第⼆个事务的修改导致第⼀个事务两次读取的数据可能不太⼀样。这就发⽣了在⼀个事务内两次读到的数据是不⼀样的情况，因此称为不可重复读。 *幻读（Phantom read）: *幻读与不可重复读类似。它发⽣在⼀个事务（T1）读取了⼏⾏数据，接着另⼀个并发事务（T2）插⼊了⼀些数据时。在随后的查询中，第⼀个事务（T1）就会发现多了⼀些原本不存在的记录，就好像发⽣了幻觉⼀样，所以称为幻读。 不可重复读和幻读区别：不可重复读的重点是修改⽐如多次读取⼀条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除⽐如多次读取⼀条记录发现记录增多或减少了。 事务隔离级别有哪些?MySQL的默认隔离级别是? *READ-UNCOMMITTED(读取未提交)： *最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。 REPEATABLE-READ(可重复读)： 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。 SERIALIZABLE(可串⾏化)： 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可重复读以及幻读。 数据库优化a) 选择合适的字段，比如邮箱字段可以设为char（6），尽量把字段设置为notnull，这样查询的时候数据库就不需要比较null值b) 使用关联查询（ left join on）查询代替子查询c) 使用union联合查询手动创建临时表d) 开启事物，当数据库执行多条语句出现错误时，事物会回滚，可以维护数据库的完整性e) 使用外键，事物可以维护数据的完整性但是它却不能保证数据的关联性，使用外键可以保证数据的关联性f) 使用索引，索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快的多的速度检索特定的行，特别是对于max，min，order by查询时，效果更明显g) 优化的查询语句，绝大多数情况下，使用索引可以提高查询的速度，但如果sql语句使用不恰当的话，索引无法发挥它的特性。 redis 简介简单来说 redis 就是⼀个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度⾮常快，因此 redis 被⼴泛应⽤于缓存⽅向。为什么要⽤ redis/为什么要⽤缓存主要从“⾼性能”和“⾼并发”这两点来看待这个问题。高性能假如⽤户第⼀次访问数据库中的某些数据。这个过程会⽐᫾慢，因为是从硬盘上读取的。将该⽤户访问的数据存在缓存中，这样下⼀次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！⾼并发：直接操作缓存能够承受的请求是远远⼤于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样⽤户的⼀部分请求会直接到缓存这⾥⽽不⽤经过数据库。 ** 缓存雪崩和缓存穿透问题解决⽅案**什么是缓存雪崩？简介：缓存同⼀时间⼤⾯积的失效，所以，后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤量请求⽽崩掉。有哪些解决办法？ 事前：尽量保证整个 redis 集群的⾼可⽤性，发现机器宕机尽快补上。选择合适的内存淘汰策略。 事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉 事后：利⽤ redis 持久化机制保存的数据尽快恢复缓存 数据结构队列（Queue）队列是数据结构中比较重要的⼀种类型，它⽀持 FIFO（先进先出），尾部添加、头部删除（先进队列的元素先出队列），跟我们⽣活中的排队类似。队列的种类 单队列（单队列就是常⻅的队列, 每次添加元素时，都是添加到队尾，存在“假溢出”的问题也就是明明有位置却不能添加的情况） 循环队列（避免了“假溢出”的问题） Set什么是 SetSet 继承于 Collection 接⼝，是⼀个不允许出现重复元素，并且⽆序的集合，主要 HashSet 和TreeSet 两⼤实现类。在判断重复元素的时候，HashSet 集合会调⽤ hashCode()和 equal()⽅法来实现；TreeSet 集合会调⽤compareTo⽅法来实现。补充：有序集合与⽆序集合说明 有序集合：集合⾥的元素可以根据 key 或 index 访问 (List、Map) ⽆序集合：集合⾥的元素只能遍历。（Set） HashSet 和 TreeSet 底层数据结构HashSet 是哈希表结构，主要利⽤ HashMap 的 key 来存储元素，计算插⼊元素的 hashCode 来获取元素在集合中的位置； List什么是List在 List 中，⽤户可以精确控制列表中每个元素的插⼊位置，另外⽤户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。 与 Set 不同，List 通常允许重复的元素。 另外 List 是有序集合⽽ Set 是⽆序集合。 List的常⻅实现类ArrayList 是⼀个数组队列，相当于动态数组。它由数组实现，随机访问效率⾼，随机插⼊、随机删除效率低。LinkedList 是⼀个双向链表。它也可以被当作堆栈、队列或双端队列进⾏操作。LinkedList随机访问效率低，但随机插⼊、随机删除效率⾼。Vector 是⽮量队列，和ArrayList⼀样，它也是⼀个动态数组，由数组实现。但是ArrayList是⾮线程安全的，⽽Vector是线程安全的。Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。","categories":[],"tags":[]},{"title":"日志管理","slug":"日志管理","date":"2020-11-24T19:39:35.000Z","updated":"2020-12-05T08:57:43.993Z","comments":true,"path":"2020/11/25/日志管理/","link":"","permalink":"http://yoursite.com/2020/11/25/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/","excerpt":"1 日志管理设计说明1.1 业务设计说明 本模块主要是实现对用户行为日志(例如谁在什么时间点执行了什么操作,访问了哪些方法,传递的什么参数,执行时长等)进行记录、查询、删除等操作。其表设计语句如下：","text":"1 日志管理设计说明1.1 业务设计说明 本模块主要是实现对用户行为日志(例如谁在什么时间点执行了什么操作,访问了哪些方法,传递的什么参数,执行时长等)进行记录、查询、删除等操作。其表设计语句如下： CREATE TABLE sys_logs ( id bigint(20) NOT NULL AUTO_INCREMENT, username varchar(50) DEFAULT NULL COMMENT ‘登陆用户名’, operation varchar(50) DEFAULT NULL COMMENT ‘用户操作’, method varchar(200) DEFAULT NULL COMMENT ‘请求方法’, params varchar(5000) DEFAULT NULL COMMENT ‘请求参数’, **time** bigint(20) NOT NULL COMMENT ‘执行时长(毫秒)’, ip varchar(64) DEFAULT NULL COMMENT ‘IP地址’, createdTime datetime DEFAULT NULL COMMENT ‘日志记录时间’, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=’系统日志’; 1.1 原型设计说明基于用户需求，实现静态页面(html/css/js)，通过静态页面为用户呈现基本需求实现， 2 日志管理列表页面呈现Controller实现▪ 业务描述与设计实现 基于日志管理的请求业务，在PageController中添加doLogUI方法，doPageUI方法分别用于返回日志列表页面，日志分页页面。 ▪ 关键代码设计与实现 第一步：在PageController中定义返回日志列表的方法。代码如下： @RequestMapping(“log/log_list”) public String doLogUI() { ​ return “sys/log_list”; } 第二步：在PageController中定义用于返回分页页面的方法。代码如下： @RequestMapping(“doPageUI”) public String doPageUI() { ​ return “common/page”; } 2.3客户端实现日志菜单事件处理▪ 业务描述与设计 首先准备日志列表页面(/templates/pages/sys/log_list.html)，然后在starter.html页面中点击日志管理菜单时异步加载日志列表页面。 ▪ 关键代码设计与实现 找到项目中的starter.html 页面，页面加载完成以后，注册日志管理菜单项的点击事件，当点击日志管理时，执行事件处理函数。关键代码如下： $(function(){ ​ doLoadUI(“load-log-id”,”log/log_list”) }) function doLoadUI(id,url){ $(&quot;#&quot;+id).click(function(){​ $(“#mainContentId”).load(url); ​ }); } 其中，load函数为jquery中的ajax异步请求函数。 日志列表页面事件处理▪ 业务描述与设计实现 当日志列表页面加载完成以后异步加载分页页面（page.html）。 ▪ 关键代码设计与实现： 在log_list.html页面中异步加载page页面，这样可以实现分页页面重用，哪里需要分页页面，哪里就进行页面加载即可。关键代码如下： $(function(){ ​ $(“#pageId”).load(“doPageUI”); }); 说明：数据加载通常是一个相对比较耗时操作，为了改善用户体验，可以先为用户呈现一个页面，数据加载时，显示数据正在加载中,数据加载完成以后再呈现数据。这样也可满足现阶段不同类型客户端需求(例如手机端,电脑端,电视端,手表端。) 3日志管理列表数据呈现服务端关键业务及代码实现Entity类实现 构建实体对象（POJO）封装从数据库查询到的记录，一行记录映射为内存中一个的这样的对象。对象属性定义时尽量与表中字段有一定的映射关系，并添加对应的set/get/toString等方法，便于对数据进行更好的操作。 ▪关键代码分析及实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 package com.cy.pj.sys.entity; import java.io.Serializable; import java.util.Date; public class SysLog implements Serializable &#123; private static final long serialVersionUID = 1L; private Integer id; //用户名 private String username; //用户操作 private String operation; //请求方法 private String method; //请求参数 private String params; //执行时长(毫秒) private Long time; //IP地址 private String ip; //创建时间 private Date createdTime; /**设置：*/ public void setId(Integer id) &#123; this.id = id; &#125; /**获取：*/ public Integer getId() &#123; return id; &#125; /**设置：用户名*/ public void setUsername(String username) &#123; this.username = username; &#125; /** 获取：用户名*/ public String getUsername() &#123; return username; &#125; /**设置：用户操作*/ public void setOperation(String operation) &#123; this.operation = operation; &#125; /**获取：用户操作*/ public String getOperation() &#123; return operation; &#125; /**设置：请求方法*/ public void setMethod(String method) &#123; this.method = method; &#125; /**获取：请求方法*/ public String getMethod() &#123; return method; &#125; /** 设置：请求参数*/ public void setParams(String params) &#123; this.params = params; &#125; /** 获取：请求参数 */ public String getParams() &#123; return params; &#125; /**设置：IP地址 */ public void setIp(String ip) &#123; this.ip = ip; &#125; /** 获取：IP地址*/ public String getIp() &#123; return ip; &#125; /** 设置：创建时间*/ public void setCreateDate(Date createdTime) &#123; this.createdTime = createdTime; &#125; /** 获取：创建时间*/ public Date getCreatedTime() &#123; return createdTime; &#125; public Long getTime() &#123; return time; &#125; public void setTime(Long time) &#123; this.time = time; &#125;&#125; 说明：通过此对象除了可以封装从数据库查询的数据，还可以封装客户端请求数据，实现层与层之间数据的传递。 Dao接口实现 业务描述及设计实现通过数据层对象，基于业务层参数数据查询日志记录总数以及当前页要呈现的用户行为日志信息。 关键代码分析及实现：123@Mapper public interface SysLogDao &#123; &#125; 第二步：在SysLogDao接口中添加getRowCount方法用于按条件统计记录总数。代码如下：1234567/** * @param username 查询条件(例如查询哪个用户的日志信息) * @return 总记录数(基于这个结果可以计算总页数) */ int getRowCount(@Param(\"username\") String username); &#125; 第三步：在SysLogDao接口中添加findPageObjects方法，基于此方法实现当前页记录的数据查询操作。代码如下：1234567891011/** * @param username 查询条件(例如查询哪个用户的日志信息) * @param startIndex 当前页的起始位置 * @param pageSize 当前页的页面大小 * @return 当前页的日志记录信息 * 数据库中每条日志信息封装到一个SysLog对象中 */List&lt;SysLog&gt; findPageObjects( @Param(\"username\")String username, @Param(\"startIndex\")Integer startIndex, @Param(\"pageSize\")Integer pageSize); 说明：1) 当DAO中方法参数多余一个时尽量使用@Param注解进行修饰并指定名字，然后在Mapper文件 中 便可以通过类似#{username}方式进行获取，否则只能通过#{arg0}，#{arg1}或者#{param1}，#{param2}等方式进行获取。2) 当DAO方法中的参数应用在动态SQL中时无论多少个参数，尽量使用@Param注解进行修饰并定义。Mapper文件实现 业务描述及设计实现基于Dao接口创建映射文件，在此文件中通过相关元素(例如select)描述要执行的数据操作 关键代码设计及实现第一步：在映射文件的设计目录(mapper/sys)中添加SysLogMapper.xml映射文件，代码如下：123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.cy.pj.sys.dao.SysLogDao\"&gt; &lt;/mapper&gt; 第二步：在映射文件中添加sql元素实现，SQL中的共性操作，代码如下12345678&lt;sql id=\"queryWhereId\"&gt; from sys_Logs &lt;where&gt; &lt;if test=\"username!=null and username!=''\"&gt; username like concat(\"%\",#&#123;username&#125;,\"%\") &lt;/if&gt; &lt;/where&gt; &lt;/sql&gt; 第三步：在映射文件中添加id为getRowCount元素，按条件统计记录总数，代码如下：12345&lt;select id=\"getRowCount\" resultType=\"int\"&gt; select count(*) &lt;include refid=\"queryWhereId\"/&gt; &lt;/select&gt; 第四步：在映射文件中添加id为findPageObjects元素，实现分页查询。代码如下：1234567 &lt;select id=\"findPageObjects\" resultType=\"com.cy.pj.sys.entity.SysLog\"&gt; select * &lt;include refid=\"queryWhereId\"/&gt; order by createdTime desc limit #&#123;startIndex&#125;,#&#123;pageSize&#125; &lt;/select&gt; 第五步:单元测试类SysLogDaoTests，对数据层方法进行测试。 123456789101112131415161718192021222324252627282930package com.cy.pj.sys.dao;import java.util.List;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import com.cy.pj.sys.entity.SysLog;@SpringBootTestpublic class SysLogDaoTests &#123; @Autowired private SysLogDao sysLogDao; @Test public void testGetRowCount() &#123; int rows=sysLogDao.getRowCount(\"admin\"); System.out.println(\"rows=\"+rows); &#125; @Test public void testFindPageObjects() &#123; List&lt;SysLog&gt; list= sysLogDao.findPageObjects(\"admin\", 0, 3); for(SysLog log:list) &#123; System.out.println(log); &#125; &#125;&#125; 3.3.4Service接口及实现类 业务描述与设计实现业务层主要是实现模块中业务逻辑的处理。在日志分页查询中，业务层对象首先要通过业务方法中的参数接收控制层数据(例如username,pageCurrent)并校验。然后基于用户名进行总记录数的查询并校验，再基于起始位置及页面大小进行当前页记录的查询，最后对查询结果进行封装并返回。 关键代码设计及实现业务值对象定义，基于此对象封装数据层返回的数据以及计算的分页信息，具体代码参考如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.cy.pj.common.vo;public class PageObject&lt;T&gt; implements Serializable &#123; private static final long serialVersionUID = 6780580291247550747L;//类泛型 /**当前页的页码值*/ private Integer pageCurrent=1; /**页面大小*/ private Integer pageSize=3; /**总行数(通过查询获得)*/ private Integer rowCount=0; /**总页数(通过计算获得)*/ private Integer pageCount=0; /**当前页记录*/ private List&lt;T&gt; records;public PageObject()&#123;&#125; public PageObject(Integer pageCurrent, Integer pageSize, Integer rowCount, List&lt;T&gt; records) &#123; super(); this.pageCurrent = pageCurrent; this.pageSize = pageSize; this.rowCount = rowCount; this.records = records;// this.pageCount=rowCount/pageSize;// if(rowCount%pageSize!=0) &#123;// pageCount++;// &#125; this.pageCount=(rowCount-1)/pageSize+1; &#125; public Integer getPageCurrent() &#123; return pageCurrent; &#125; public void setPageCurrent(Integer pageCurrent) &#123; this.pageCurrent = pageCurrent; &#125; public Integer getPageSize() &#123; return pageSize; &#125; public void setPageSize(Integer pageSize) &#123; this.pageSize = pageSize; &#125; public Integer getRowCount() &#123; return rowCount; &#125; public void setRowCount(Integer rowCount) &#123; this.rowCount = rowCount; &#125; public Integer getPageCount() &#123; return pageCount; &#125; public void setPageCount(Integer pageCount) &#123; this.pageCount = pageCount; &#125; public List&lt;T&gt; getRecords() &#123; return records; &#125; public void setRecords(List&lt;T&gt; records) &#123; this.records = records; &#125; &#125; 定义日志业务接口及方法，暴露外界对日志业务数据的访问，其代码参考如下：12345678910package com.cy.pj.sys.service;public interface SysLogService &#123; /** * @param name 基于条件查询时的参数名 * @param pageCurrent 当前的页码值 * @return 当前页记录+分页信息 */ PageObject&lt;SysLog&gt; findPageObjects( String username, Integer pageCurrent); 日志业务接口及实现类，用于具体执行日志业务数据的分页查询操作,其代码如下：12345678910111213141516171819202122232425262728293031323334353637383940package com.cy.pj.sys.service.impl;@Servicepublic class SysLogServiceImpl implements SysLogService&#123; @Autowired private SysLogDao sysLogDao; @Override public PageObject&lt;SysLog&gt; findPageObjects( String name, Integer pageCurrent) &#123; //1.验证参数合法性 //1.1验证pageCurrent的合法性， //不合法抛出IllegalArgumentException异常 if(pageCurrent==null||pageCurrent&lt;1) throw new IllegalArgumentException(\"当前页码不正确\"); //2.基于条件查询总记录数 //2.1) 执行查询 int rowCount=sysLogDao.getRowCount(name); //2.2) 验证查询结果，假如结果为0不再执行如下操作 if(rowCount==0) throw new ServiceException(\"系统没有查到对应记录\"); //3.基于条件查询当前页记录(pageSize定义为2) //3.1)定义pageSize int pageSize=2; //3.2)计算startIndex int startIndex=(pageCurrent-1)*pageSize; //3.3)执行当前数据的查询操作 List&lt;SysLog&gt; records= sysLogDao.findPageObjects(name, startIndex, pageSize); //4.对分页信息以及当前页记录进行封装 //4.1)构建PageObject对象 PageObject&lt;SysLog&gt; pageObject=new PageObject&lt;&gt;(); //4.2)封装数据 pageObject.setPageCurrent(pageCurrent); pageObject.setPageSize(pageSize); pageObject.setRowCount(rowCount); pageObject.setRecords(records); pageObject.setPageCount((rowCount-1)/pageSize+1); //5.返回封装结果。 return pageObject; &#125;&#125; 在当前方法中需要的ServiceException是一个自己定义的异常, 通过自定义异常可更好的实现对业务问题的描述，同时可以更好的提高用户体验。参考代码如下：123456789101112131415package com.cy.pj.common.exception;public class ServiceException extends RuntimeException &#123; private static final long serialVersionUID = 7793296502722655579L; public ServiceException() &#123; super(); &#125; public ServiceException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125; public ServiceException(Throwable cause) &#123; super(cause); // TODO Auto-generated constructor stub &#125; &#125; 定义Service对象的单元测试类，代码如下：123456789101112131415161718192021package com.cy.pj.sys.service;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import com.cy.pj.common.vo.PageObject;import com.cy.pj.sys.entity.SysLog;@SpringBootTestpublic class SysLogServiceTests &#123; @Autowired private SysLogService sysLogService; @Test public void testFindPageObjects() &#123; PageObject&lt;SysLog&gt; pageObject= sysLogService.findPageObjects(\"admin\", 1); System.out.println(pageObject); &#125;&#125; 3.3.5Controller类实现 业务描述与设计实现控制层对象主要负责请求和响应数据的处理，例如，本模块首先要通过控制层对象处理请求参数，然后通过业务层对象执行业务逻辑，再通过VO对象封装响应结果(主要对业务层数据添加状态信息)，最后将响应结果转换为JSON格式的字符串响应到客户端。 关键代码设计与实现定义控制层值对象（VO），目的是基于此对象封装控制层响应结果(在此对象中主要是为业务层执行结果添加状态信息)。Spring MVC框架在响应时可以调用相关API（例如jackson）将其对象转换为JSON格式字符串。1234567891011121314151617181920212223242526272829303132333435363738394041package com.cy.pj.common.vo;public class JsonResult implements Serializable &#123; private static final long serialVersionUID = -856924038217431339L;//SysResult/Result/R /**状态码*/ private int state=1;//1表示SUCCESS,0表示ERROR /**状态信息*/ private String message=\"ok\"; /**正确数据*/ private Object data; public JsonResult() &#123;&#125; public JsonResult(String message)&#123; this.message=message; &#125; /**一般查询时调用，封装查询结果*/ public JsonResult(Object data) &#123; this.data=data; &#125; /**出现异常时时调用*/ public JsonResult(Throwable t)&#123; this.state=0; this.message=t.getMessage(); &#125; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125;&#125; 定义Controller类，并将此类对象使用Spring框架中的@Controller注解进行标识，表示此类对象要交给Spring管理。然后基于@RequestMapping注解为此类定义根路径映射。代码参考如下：1234567package com.cy.pj.sys.controller;@Controller@RequestMapping(&quot;/log/&quot;)public class SysLogController &#123; @Autowired private SysLogService sysLogService;&#125; 在Controller类中添加分页请求处理方法，代码参考如下： 1234567@RequestMapping(\"doFindPageObjects\")@ResponseBodypublic JsonResult doFindPageObjects(String username,Integer pageCurrent)&#123; PageObject&lt;SysLog&gt; pageObject= sysLogService.findPageObjects(username,pageCurrent);return new JsonResult(pageObject);&#125; 定义全局异常处理类，对控制层可能出现的异常，进行统一异常处理，代码如下： 123456789101112131415161718package com.cy.pj.common.web;import java.util.logging.Logger;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import com.cy.pj.common.vo.JsonResult;@ControllerAdvicepublic class GlobalExceptionHandler &#123; //JDK中的自带的日志API @ExceptionHandler(RuntimeException.class) @ResponseBody public JsonResult doHandleRuntimeException( RuntimeException e)&#123; e.printStackTrace();//也可以写日志 异常信息 return new JsonResult(e);//封装 &#125;&#125; 客户端关键业务及代码实现日志列表信息呈现 业务描述与设计实现日志分页页面加载完成以后，向服务端发起异步请求加载日志信息，当日志信息加载完成需要将日志信息、分页信息呈现到列表页面上。 关键代码设计与实现第一步：分页页面加载完成，向服务端发起异步请求，代码参考如下：123456 $(function()&#123; //为什么要将doGetObjects函数写到load函数对应的回调内部。 $(\"#pageId\").load(\"doPageUI\",function()&#123; doGetObjects(); &#125;);&#125;); 第二步：定义异步请求处理函数，代码参考如下：12345678910111213function doGetObjects()&#123; //debugger;//断点调试 //1.定义url和参数 var url=\"log/doFindPageObjects\" var params=&#123;\"pageCurrent\":1&#125;;//pageCurrent=2 //2.发起异步请求 //请问如下ajax请求的回调函数参数名可以是任意吗？//可以,必须符合标识符的规范 $.getJSON(url,params,function(result)&#123; //请问result是一个字符串还是json格式的js对象？对象 doHandleQueryResponseResult(result); &#125; );//特殊的ajax函数 &#125; 第三步：定义回调函数，处理服务端的响应结果。代码如下：12345678910function doHandleQueryResponseResult (result)&#123; //JsonResult if(result.state==1)&#123;//ok //更新table中tbody内部的数据 doSetTableBodyRows(result.data.records);//将数据呈现在页面上 //更新页面page.html分页数据 //doSetPagination(result.data); //此方法写到page.html中 &#125;else&#123; alert(result.message); &#125; &#125; 第四步：将异步响应结果呈现在table的tbody位置。代码参考如下：12345678910111213141516function doSetTableBodyRows(records)&#123; //1.获取tbody对象，并清空对象 var tBody=$(\"#tbodyId\"); tBody.empty(); //2.迭代records记录，并将其内容追加到tbody for(var i in records)&#123; //2.1 构建tr对象 var tr=$(\"&lt;tr&gt;&lt;/tr&gt;\"); //2.2 构建tds对象 var tds=doCreateTds(records[i]); //2.3 将tds追加到tr中 tr.append(tds); //2.4 将tr追加到tbody中 tBody.append(tr); &#125; &#125; 第五步：创建每行中的td元素，并填充具体业务数据。代码参考如下：12345678910 function doCreateTds(data)&#123; var tds=\"&lt;td&gt;&lt;input type='checkbox' class='cBox' name='cItem' value='\"+data.id+\"'&gt;&lt;/td&gt;\"+ \"&lt;td&gt;\"+data.username+\"&lt;/td&gt;\"+ \"&lt;td&gt;\"+data.operation+\"&lt;/td&gt;\"+ \"&lt;td&gt;\"+data.method+\"&lt;/td&gt;\"+ \"&lt;td&gt;\"+data.params+\"&lt;/td&gt;\"+ \"&lt;td&gt;\"+data.ip+\"&lt;/td&gt;\"+ \"&lt;td&gt;\"+data.time+\"&lt;/td&gt;\"; return tds; &#125; 分页数据信息呈现 业务描述与设计实现日志信息列表初始化完成以后初始化分页数据（调用setPagination函数），然后再点击上一页，下一页等操作时，更新页码值，执行基于当前页码值的查询。 关键代码设计与实现：第一步：在page.html页面中定义doSetPagination方法(实现分页数据初始化)，代码如下123456789function doSetPagination(page)&#123; //1.始化数据 $(\".rowCount\").html(\"总记录数(\"+page.rowCount+\")\"); $(\".pageCount\").html(\"总页数(\"+page.pageCount+\")\"); $(\".pageCurrent\").html(\"当前页(\"+page.pageCurrent+\")\"); //2.绑定数据(为后续对此数据的使用提供服务) $(\"#pageId\").data(\"pageCurrent\",page.pageCurrent); $(\"#pageId\").data(\"pageCount\",page.pageCount); &#125; 第二步：分页页面page.html中注册点击事件。代码如下：1234$(function()&#123; //事件注册 $(\"#pageId\").on(\"click\",\".first,.pre,.next,.last\",doJumpToPage);&#125;) 第三步：定义doJumpToPage方法(通过此方法实现当前数据查询)123456789101112131415161718192021222324 function doJumpToPage()&#123; //1.获取点击对象的class值 var cls=$(this).prop(&quot;class&quot;);//Property //2.基于点击的对象执行pageCurrent值的修改 //2.1获取pageCurrent,pageCount的当前值 var pageCurrent=$(&quot;#pageId&quot;).data(&quot;pageCurrent&quot;); var pageCount=$(&quot;#pageId&quot;).data(&quot;pageCount&quot;); //2.2修改pageCurrent的值 if(cls==&quot;first&quot;)&#123;//首页 pageCurrent=1; &#125;else if(cls==&quot;pre&quot;&amp;&amp;pageCurrent&gt;1)&#123;//上一页 pageCurrent--; &#125;else if(cls==&quot;next&quot;&amp;&amp;pageCurrent&lt;pageCount)&#123;//下一页 pageCurrent++; &#125;else if(cls==&quot;last&quot;)&#123;//最后一页 pageCurrent=pageCount; &#125;else&#123; return;&#125; //3.对pageCurrent值进行重新绑定 $(&quot;#pageId&quot;).data(&quot;pageCurrent&quot;,pageCurrent); //4.基于新的pageCurrent的值进行当前页数据查询 doGetObjects(); &#125; 修改分页查询方法:123456789101112131415161718function doGetObjects()&#123; //debugger;//断点调试 //1.定义url和参数 var url=\"log/doFindPageObjects\" //? 请问data函数的含义是什么？(从指定元素上获取绑定的数据) //此数据会在何时进行绑定？(setPagination,doQueryObjects) var pageCurrent=$(\"#pageId\").data(\"pageCurrent\"); //为什么要执行如下语句的判定，然后初始化pageCurrent的值为1 //pageCurrent参数在没有赋值的情况下，默认初始值应该为1. if(!pageCurrent) pageCurrent=1; var params=&#123;\"pageCurrent\":pageCurrent&#125;;//pageCurrent=2 //2.发起异步请求 //请问如下ajax请求的回调函数参数名可以是任意吗？可以,必须符合标识符的规范 $.getJSON(url,params,function(result)&#123; //请问result是一个字符串还是json格式的js对象？对象 doHandleQueryResponseResult(result); &#125; );//特殊的ajax函数 &#125; 3.4.4列表页面信息查询实现 业务描述及设计当用户点击日志列表的查询按钮时，基于用户输入的用户名进行有条件的分页查询，并将查询结果呈现在页面。 关键代码设计与实现：第一步：日志列表页面加载完成，在查询按钮上进行事件注册。代码如下： $(“.input-group-btn”).on(“click”,”.btn-search”,doQueryObjects)第二步：定义查询按钮对应的点击事件处理函数。代码如下：12345678function doQueryObjects()&#123; //为什么要在此位置初始化pageCurrent的值为1? //数据查询时页码的初始位置也应该是第一页 $(\"#pageId\").data(\"pageCurrent\",1); //为什么要调用doGetObjects函数？ //重用js代码，简化jS代码编写。 doGetObjects(); &#125; 第三步：在分页查询函数中追加name参数定义(看黄色底色部分)，代码如下：123456789101112131415161718192021222324function doGetObjects()&#123; //debugger;//断点调试 //1.定义url和参数 var url=\"log/doFindPageObjects\" //? 请问data函数的含义是什么？(从指定元素上获取绑定的数据) //此数据会在何时进行绑定？(setPagination,doQueryObjects) var pageCurrent=$(\"#pageId\").data(\"pageCurrent\"); //为什么要执行如下语句的判定，然后初始化pageCurrent的值为1 //pageCurrent参数在没有赋值的情况下，默认初始值应该为1. if(!pageCurrent) pageCurrent=1; var params=&#123;\"pageCurrent\":pageCurrent&#125;; //为什么此位置要获取查询参数的值? //一种冗余的应用方法，目的时让此函数在查询时可以重用。 var username=$(\"#searchNameId\").val(); //如下语句的含义是什么？动态在json格式的js对象中添加key/value, if(username) params.username=username;//查询时需要 //2.发起异步请求 //请问如下ajax请求的回调函数参数名可以是任意吗？可以,必须符合标识符的规范 $.getJSON(url,params,function(result)&#123; //请问result是一个字符串还是json格式的js对象？对象 doHandleQueryResponseResult(result); &#125; ); &#125;","categories":[],"tags":[]},{"title":"Python基础","slug":"Python基础","date":"2020-02-23T21:43:03.000Z","updated":"2020-07-16T02:07:52.582Z","comments":true,"path":"2020/02/24/Python基础/","link":"","permalink":"http://yoursite.com/2020/02/24/Python%E5%9F%BA%E7%A1%80/","excerpt":"python基础概述： ​ 解释型的面向对象语言 需要使用一个专门的解释器翻译成机器语言，执行一次翻译一次","text":"python基础概述： ​ 解释型的面向对象语言 需要使用一个专门的解释器翻译成机器语言，执行一次翻译一次 java C 编译型语言：需要专门的编译器把高级语言编译成可执行文件，只需要编译一次。程序执行效率比较高 优点： 1 面向对象语言 2 免费 开源 3 可移植(win linux mac) 4 可扩展性 5 可以混合编程 6 应用广泛 ​ 爬虫 web 人工智能 大数据(轻量级) 数据分析 算法 游戏 图像音频处理 教育 7 简单易学 开发效率高 维护成本比较低 缺点： 相比与C c++ java 等执行速度不够快 环境安装略 语法规范：单行注释 在行首添加 #号 快捷键： ctrl + ? 多行注释： ‘’’ ‘’’ “”” “”” 三单或三双引号进行多行注释 缩进：默认4个英文空格符 使用快捷键tab 向右缩进 ​ 向左缩进 shift + tab 输入输出语句input print print(val, val2, val3 ) 基本的数据类型数字类型（整型 浮点型 复数）整型 int 浮点型 float 复数 虚部使用j表示 格式： a + bj 示例： 5 + 6j 基本的运算符1+ - * / % **（幂运算） //（取整） 除法：返回值为浮点型 取整：得到的数去掉小数向下取整(向左取整) 幂运算： ** 查看数据类型type()方法 查看某个对象的数据类型isinstance(obj, type) 用来判断某个对象是不是对应的类型，是则返回True 否则返回False 布尔类型用来表示真和假两种状态，对应的值有两种 True False True + False = ? 1 True + True = ? 2 True 表示真可以用1来表示 False 表示假可以用0表示 空值 (None)表示不存在的一个特殊对象 作用：用来占位 用来解除变量的绑定关系 pow()函数表示： pow(x, y, z=None) 对x进行y次方在对z求余 x ** y % z 如果不给z赋值则对应表达式为 x ** y i = 2.3 j = int(i) 变量用来绑定一个数据对象的标识符 标识符命名的规则： 由数字 字母 下划线组成的符号 不能以数字开头 严格区分大小写 必须能见名知意 不能使用python的关键字 查看python的关键字 12import keywordprint(keyword.kwlist) 驼峰命名法下划线命名法： 单词间可以使用下划线连接 赋值语句格式： 变量名 = 表达式(一个数字或者数字和运算符组成的式子) 作用： 1 没有此变量是，创建一个变量，绑定到表达式 2 变量存在时，改变变量的绑定关系 说明： 1 使用变量前需先赋值 2 一个变量只能绑定在一个对象上 a = 10 3 一个对象可以关联多个变量 b = 10 c = 10 序列赋值语法：格式 变量1, 变量2, 变量3, … = 对象1，对象2，对象3，… 删除变量格式： del 变量名 常用的运算符1&gt; &lt; == != &lt;= &gt;= 返回值类型为布尔类型 链式比较：格式： val 比较运算符 val2 比较运算符1 val3 12a = 1001 &lt; a &lt; 60 复合运算符y += 1 y = y + 1 x -= 1 z *= 2 布尔运算not （布尔取非) and （布尔与) x and y or(布尔或) x or y is 与 is not运算符作用：判断两个变量(对象)是否绑定同一个对象 依据：通过两个变量的id地址来判断 语法： x is y x is not y -6 -5 0 255 256 257 -5~256之间的整数都是在电脑中固定位置，不需要单独开辟新的地址存储 范围以外的整数咋使用时都会在内存中开辟一个新的空间，多次创建则每次开辟一个不同的空间 if语句作用：根据条件选择性的执行某条语句或者语句块 语法： 1234if 真值表达式: 语句块1else: 语句块2 练习： 使用input语句随便输入一个数字判断输入的数字的奇偶性。 在python中字符串不能和数字做加减运算，如需要运算必须转换类型。 123456i = int(input(&quot;请输入一个整数&quot;))print(type(i))if i % 2 == 0: print(i,&apos;是偶数&apos;)else: print(i,&quot;是奇数&quot;) 语法2： 1234567if 真值表达式1: 语句块1elif 真值表达式2: 语句块2...else: 语句块n 说明： else子句最多有1个或没有 elif子句可以不写也可以写多个 执行顺序先判断真值表达式1是否为真，为真则执行语句块1并结束if语句，为假时判断真值表达式2是否为真，为真执行语句块2，以此类推当所有的真值表达式都不满足时才执行else子句。 练习： 出租车计价： 起步价 8元 公里数大于5小于10时每公里4元 公里数大于10时超出部分每公里6元。 使用input输入一个公里数，最终输出一个应付金额。 if嵌套if语句可以嵌套一个新的if语句在内部 如： 123456i = int(input(\"请输入一个数字\"))if i &gt; 10: if i % 2 == 0: print(i,\"大于10并且是偶数\")else: print(i,\"小于10\") 复习输入输出语句input 输入的对象为字符串类型，如需要改变类型需强制转换 print() 当输出的值有多个时(大于等于2)我们可以使用sep参数改变输出结果之间的连接符 12print(1,2,3)print(1,2,3,sep=\"#\") 快捷键： 注释：ctrl + ? 缩进： tab ​ 向左缩进 shift + tab 运行文件： ​ ctrl + shift + F10 运算符12+ - * / % ** // 复合运算符1+= -= *= /= .... 比较运算符1&gt; &gt;= &lt; &lt;= == != === 链式比较符13 &lt; 5 &lt; 8 is is not运算符-5 ~ 256之间的整数 用is判断是返回结果为True type() 查看对象的类型isinstance 判断对象是否为某个给定的类型，是返回True基本的数据类型数字类型int float 复数 126 + 6j6 + 6 * j #错误 布尔类型：只有两个值表示真假，True 和 False 布尔运算符1and or not if语句格式： 123456789if 真值表达式1: 语句块1elif 真值表达式2： 语句块2elif 真值表达式3： 语句块3。。。else: 语句块n 说明： elif子句可以不写，也可以写多个 else子句可以省略不写，写的话做多写一个 if语句的嵌套 练习： 去超市买蔬菜： 使用input输入是否为会员 输入买了多少斤 会员价： 3.68元 非会员： 4元 最终输入应付金额 12345678s = input(\"是否为会员\")j = float(input(\"请输入购买的斤数:\"))# # if s == \"是\":# # print(3.68 * j)# # elif s == \"否\":# # print(4 * j)# # else:# # print(\"输入有误！\") day02条件表达式语法： 表达式1 if 真值表达式 else 真值表达式2 作用： 根据真值表达式返回结果选择性的表达式1或表达式2，并返回结果 运行： 先判断真值表达式是否为真，为真执行表达式1，否则执行表达式2 123s = input(\"是否为会员\")j = float(input(\"请输入购买的斤数:\"))print(3.68 * j if s == \"是\" else 4 * j) 字符串作用：用来记录文本信息 表示方法： 使用引号将内容括起来，可以是单引号 ‘ ‘ 双引号 “ ” 三单引号‘’‘ ’‘’ 三双引号 “”” “”” 说明： 单引号中可以存在双引号，双引号不作为字符串的结束符 双引号中可以存在单引号，。。。。(同上) 如果想要一个字符串输出格式为： 白日依山尽 黄河入海流 1print(\"白日依山尽\\n黄河入海流\") 123s = \"\"\"白日依山尽黄河入海流\"\"\"print(s) 三单/双引号字符串内容如果需要换行时，直接按回车键换行不需要使用换行符，最终输出结果会在回车键处自动换行。 转义字符字符串的字面值表示中用反斜杠\\后跟一些字符来代表特殊字符 12 符号 描述 符号 描述 \\‘ 代表一个单引号 \\“ 代表一个双引号 \\n 换行符 \\\\ 代表一个反斜杠 \\r 返回光标至首行 \\t 水平制表符 123print(1 end=\"\\t\")print(2 end=\"\\t\")print(3) 补充： print(val,val2,sep=” “, end=”\\n”) end参数默认为换行符，表示的为与输出后与下一次输出的连接符。 问题： 1如何：让print(&quot;\\\\\\\\\\\\&quot;)输出结果为\\\\\\\\\\\\而不是\\\\\\ 解决办法： raw字符串(原始字符串) 格式： r”字符串内容” 作用：让转义符无效(显示原始的字符串内容) 比较运算符：符号： 1== != &gt; &gt;= &lt; &lt;= 依据字符串的Unicode编码值依次进行比较 1'abd'&gt;\"abc\" #True 函数： ord(x) 返回一个字符的Unicode编码值 chr(i) 返回Unicode编码值对应的字符 123print(ord(&quot;d&quot;))print(ord(&quot;c&quot;))print(chr(100)) is is not in / not in运算符作用： 判断某个字符或字符串是否存在于另一个字符串中(序列)，如果存在返回True否则返回False 12345'2' in '123' #True5 in \"abc56\" #错误示例\"ac\" not in \"abc\" #True'ac' in \"abc\" # False\"I'm\" in \"I'm ....\" # True 运算符1+ * += *= 123456789101112+字符串的拼接1 \"abc\" + \"def\" #\"abcdef\"2 'ab' * \"e\" #错误，字符串做乘法运算的时候其后必须乘以正整数3 \"a\" * 6 #\"aaaaaa\"4 \"a\" + 6 #错误不能直接和数字做加运算 \"a\" + str(6) s = \"a\"5 s+= \"bc\" \"abc\"6 s *= 3 \"abcabcabc\" 字符串的构造函数str() 用来将一个对象强制转换为字符串类型 123a = 6 print(type(a)) # intprint(type(str(6))) # str 字符串的索引操作格式：字符串[整数表达式] 123s = &quot;abcde&quot;s[0] # &apos;a&apos;s[-1] # &apos;e&apos; 说明： 1 字符串(序列)可以通过索引(index)去访问序列中的对象 2 正向索引第一个元素对应的下标为0，第二个为1，一次类推；反向索引时最后一个元素对象下标为-1，倒数第二个对应下标为-2，以此类推 字符串 a b c d e 正向索引下标 0 1 2 3 4 反向索引下标 -5 -4 -3 -2 -1 字符串切片格式： S[start : stop : step] S[: stop] 从序列开头切到stop但不包含stop下标对应的元素 S[::] 从头切到尾 S[start : ] 从起始位置切到结束 start : 切片的开始点 stop: 切片的终止点，但是不包含该小标对应的元素切不到 stop：步长，默认为1 12345s = &quot;abcdef&quot;&apos;ace&apos;s[0:5:2] s[0:6:2]#能否切出如下结果&quot;fedcba&quot; 回文：正向读与反向对时一样 上海自来水来自海上 使用input输入一段内容判断输入内容是否为回文 12345s = input(\"请输入一段文字\")if s == s[::-1]: print(s,'是回文')else: print(\"不是回文\") 123456names = \"刘备张飞关羽\" 使用切片获取三人的姓 #names[::2]s = 'abcdefg' --&gt; \"cde\" s[2:5] --&gt; \"bdg\" #错误无法用切片实现 --&gt; \"ad\" # s[0:4:3] --&gt; \"eca\" #s[-3::-2] --&gt; \"gd\" #s[:-6:-3] 能不能对字符串进行索引赋值操作？ 字符串不能进行索引赋值操作，字符串是不可变的数据类型 123s = \"abc\"s[0] = '1'print(s) 因为字符串可以进行索引操作，所以字符串也是可迭代对象 可迭代对象：一个对象中的元素可以依次拿出来 循环while 循环： 语法： 1234while 真值表达式: 语句块1else: 语句块2 说明： 程序运行时先判断真值表达式是否为真，为真则执行语句块1，然后继续判断真值表达式是否为真，直到真值表达式为假时执行else子句然后结束程序 如果循环为死循环时else子句永远不被执行 else子句可以不写 12345i = 0s = 'abc'while i &lt; 3: print(s[i]) i += 1 12breakcontinue 练习： 12s = \"123b456a\"使用循环求s字符串中数字的和 12345678i = 0s = '123a456b'sum = 0while i &lt; 8: if s[i] not in 'ab': sum+= int(s[i]) i += 1print(sum) 作业： 随机输入一个字符串找出最大的元素，和最小的元素。 回顾： 条件表达式格式： 表达式1 if 真值表达式 else 表达式2 1min = min if s[i] &gt; min else s[i] 字符串(str)单双引号 三单/双引号 单双引号如果需要换行要使用\\n 三单/双引号直接使用回车键实现换行 单引号可以存在于双引号中，不表示字符串的结束，同理双引号与单引号类似 str() 字符串的构造方法 也称强制转换符 索引/切片练习： 1234567s = &apos;abcdefg&apos;使用正向索引获取元素 e g反向 f使用切片获取如下字符串：&quot;bdf&quot; s[1:6:2] s[1::2]&quot;ec&quot; s[-3:-6:-2] s[4:1:-2]&apos;edb&apos; #错误 说明： 如果正向索引时步长为负数，则start &gt; stop值 正向索引时步长为正数，start&lt; stop 字符串的比较运算符12345#繁琐的比较操作s = &quot;135af0&quot;ord(s[1]) &gt; ord(s[2])a = ord(s[1])min = chr(a) 1&gt; &lt; &gt;= &lt;= == != 1&apos;c&apos; &gt; &apos;b&apos; 字符串逻辑运算符1+ += * *= 12 day03序列(字符串)内建函数： len(x) 读取序列元素个数(序列长度) max(x) 求序列中最大元素 min(x) 求序列中最小的元素 sum(x) 对序列进行求和(元素必须为数字类型) 123456s = \"123abc\"len(s) # 6max(s) # 'c'min(s) # '1'print(max(s),min(s)) while循环的嵌套格式 1234567while 真值表达式1: while 真值表达式2 语句块1 else: 语句块2else: 语句块3 练习： 1~100整数求和 使用while循环实现99乘法表输出 1234567891011121314151617i = 1sum = 0while i &lt; 101: sum += i i += 1print(sum)#练习2j = 1num = 0while j &lt; 10: i = j while i &lt; 10: print(j ,\"*\",i,'=',j*i, end=\"\\t\") i += 1 print() j+=1 字符串的常用方法使用s代表字符串 函数 含义 s.isdigit() 判断字符串是否全为数字 s.isalpha() 判断是否全为字母 s.isspace() 判断是否全为空白符(空格) s.isalnum() 判断字符串都是字符（字母 数字 汉字）（使用频率特地） s.isupper() 判断字符是否全为大写字符 s.islower() 判断字符是否全为小写字符 s.upper() 将英文字母全部转换成大写 s.lower() 将英文字母全部转换成小写 s.capitalize() 让字符串的首字母大写（字符串的第一个元素） s.strip() 返回去掉字符串左右空白(空格 /n)字符的新的字符串 s.lstrip() 返回去掉左侧空白字符的新的字符串 s.rstrip() 返回去掉右侧空白字符的新的字符串 s.rjust(width) 返回一个在指定width中右对齐的字符串 ljust()左对齐，空白部分使用空格填充 s.find(x) 返回字符原字符串中的下标，如不存在返回-1 s.find(x,start,end) 获取字符串中使用start和end范围内的字符x的下标如果找不到则返回-1 s.replace(old, new, count) 匹配出字符串中old字符内容替换成新的字符内容，count表示替换个数 s.center(width,fill) 在给定宽度内让字符串居中，左右填充空白 s.count(width,fill) 获取查找字符x在字符串中出现的次数 s.find(x, start, end)start和end相当于切片，在设定范围内查找元素x是否存在存在返回在字符串中对应的小标 12345s = \"12345666\"s.find('6') #5 #当查找元素有多个时，只返回第一次出现元素的下标s.find('1') #0s.find('1',3) #-1 找不到 #从下标为3处开始查找s.find('2',3,5) #-1 是在字符串下标3~5区间查找元素\"2\"不存在返回-1 s.replace(old, new, count)count限制替换的个数(正整数) 当不添加count参数是默认将匹配到的内容全部替换成新的字符串内容 如果给定count则替换前conut个内容，如果count值大于字符串中old个数，则全部替换 当old不存在时则原字符串不改变 12345s = \"1234566543\"s.replace('6','8') #\"1234588543\"s.replace(\"5\",'6',1) #\"1234666543\"s.replace(\"5\",'6',5) #\"1234666543\"s.replace(\"a\",'b') #\"1234566543\" s.center(width,fill)在给定宽度内让字符串居中，左右默认填充空格，也可以使用fill参数设定空白填充符 123s = \"abc\"s.center(20) #' abc 's.center(10,'-') #'---abc----' s.count(x,start,end) 获取查找字符x在字符串中出现的次数 1234s = &quot;aaabbbcdefg&quot;s.count(&apos;a&apos;) #3s.count(&apos;a&apos;,1) #2s.count(&apos;h&apos;) #0 练习： 随便输入一个字符串，对数字字符进行求和 12345678s = input('随机输入内容：')i = 0sum = 0while i &lt; len(s): if s[i].isdigit(): sum += int(s[i]) i += 1print(sum) for循环作用： 是用来遍历序列或可迭代对象中的每一个元素 可迭代对象： 指能一次获取数据的对象，包括字符串、列表、元组、字典、集合 格式： 1234for 变量 in 可迭代对象: 语句块1else: 语句块2 说明： 1 变量绑定的值依次为可迭代对象每次给出的元素，然后执行语句块1 当可迭代向的元素被遍历结束后for循环结束执行else子句。 2 else可以省略 12345s = \"abcdefg\"for i in s: print(i)else: print(\"程序结束~\") 3 当在循环内使用break语句终止循环式else子句不再执行(同样适用于while循环) range()函数作用： 用来生成依次列整数的可迭代对象(整数序列生成器) 格式： range(start, stop, step) range(stop) range(start, stop) start : 起始值，默认为0，可以省略 stop: 终止值，必须存在，且终止值无法得到 step：步长，默认为1， 值可正可负 也可以省略 123range(1,10) #123456789range(10) #0123456789range(-5,6,2) #-5 -3 -1 1 3 练习： 使用for循环实现1~100的求和 9的阶乘 for循环的嵌套格式： iterable：可迭代对象 1234567for i in iterable： for i in iterable1： 语句块 else: 语句块1else: 语句块2 使用for循环查看50以内的质数(素数) 123456789for i in range(2,51): for j in range(2,int(i**0.5)+1): #int(i**0.5)+1 #int(i/2) # i if i % j == 0: break else: print(i,end=\"\\t\") 循环总结： while循环：主要哟用于未知循环次数 for循环：主要用于已知循环次数 %s %d %f %2d %.2f %s 字符串占位符 %d 整数占位符 %f 浮点型占位符 123s = &quot;旺财&quot;v = 15print(&quot;%s以%d的速度向你跑来!&quot; % (s,v)) format函数格式化输出内容 语法： 1&quot;&#123;&#125;,&#123;&#125;&quot;.format(value1,value2) 1234s = &quot;旺财&quot;v = 15print(&quot;&#123;0&#125;以&#123;1&#125;的速度向你跑来!&quot;.format(s,v))print(&quot;&#123;1&#125;以&#123;0&#125;的速度向你跑来!&quot;.format(s,v)) 在python3.6以上版本中可以使用如下格式实现格式化输出内容 123s = &quot;旺财&quot;v = 15print(f&quot;&#123;s&#125;以&#123;v&#125;的速度向你跑来!&quot;) 列表 list定义: 1 是由一系列特定元素组成的，元素和元素之间没有关联关系， 只有先后顺序 2 列表也是序列 3 列表中的元素可以是任意数据类型 4 列表是可变的数据类型 列表的表示方法：使用[]括起来，元素与元素之间用逗号隔开 创建列表创建空列表L = [] 非空列表12l = [1,&apos;a&apos;]l = [&apos;a&apos;,[1,3,&apos;bc&apos;]] 列表的构造方法list(iterable) L = list() #空列表 L1 = list(“abc”) L2 = list(123)#错误 12l2 = list(&quot;1234&quot;) #[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]l3 = list(range(5)) #[0, 1, 2, 3, 4] 列表的遍历123l = [1,2,3,[4,5,6],7]for i in list： print(i) 作用：遍历列表中的每一个元素 列表的运算符123456789+ += 列表的拼接l = [1,2,3]l2 = [4,5,'a']print(l + l2)* *=将列表中的元素重复多少遍 列表可以进行大小比较？ 不会对列表进行大小比较，如要比较时比较列表个位置元素的类型要一一对应 列表 in / not in判断一个元素是否在列表中 123l = [1,2,3][1,2] in l #False1 in l #True 列表的索引操作格式： 同字符串 L[整数表达式] 123l [&apos;a&apos;,&apos;b&apos;,1,0,2]l[3] #0l[-2] #0 规则与字符串索引相同 切片： 等同于字符串切片 12345678L = [1,2,3,4,5,6,7,8]使用切片将列表中所有的偶数切出 [6,3]L = [1,2,3,4,5,6,7,8]print(L[1::2])print(L[-3:-7:-3])print(L[5:1:-3]) 练习： 列表L = [1,2,3,[‘a’,’b’],4,5,6] 使用索引获取元素‘b’ 1L[3][1] 因为列表是列表是可变的数据类型，所以可以通过索引/切片赋值操作改变列表元素 索引赋值格式： 1L[整数表达式] = 值 123L = [1,2,3,4]即将元素3改为&apos;a&apos;l[2] = &apos;a&apos; 列表(序列)的内建函数： len() max() min() sum()元素必须全为数字类型 常用函数： L.append(x) 将元素x追加到列表L后 1234s = 'hello'l = [1,2,3]l.append(s)print(l) 作业： 使用列表实现斐波那契数,（实现前十位数即可） 1[1,1,2,3,5,8,13,21,...] L=[1,1] while len(L)&lt;10: L.append(L[-1]+L[-2]) print(L)使用for循环求100~1000以内的水仙花数 11** 3 + 5 ** 3 + 3 ** 3 = 153 1234567for a in range(0,9,1): for b in range(0,9,1): for c in range(0,9,1): m = a**3 + b**3 + c**3 n = int(str(a) + str(b) + str(c)) if m==n: print(m)","categories":[],"tags":[]},{"title":"关于我们","slug":"关于我们","date":"2020-01-09T23:48:48.000Z","updated":"2020-01-09T15:56:42.126Z","comments":true,"path":"2020/01/10/关于我们/","link":"","permalink":"http://yoursite.com/2020/01/10/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/","excerpt":"","text":"2020.1.9 我们的故事开始了！","categories":[],"tags":[]},{"title":"期末不挂科指南","slug":"期末不挂科指南","date":"2019-12-27T21:31:34.000Z","updated":"2020-01-06T15:24:32.262Z","comments":true,"path":"2019/12/28/期末不挂科指南/","link":"","permalink":"http://yoursite.com/2019/12/28/%E6%9C%9F%E6%9C%AB%E4%B8%8D%E6%8C%82%E7%A7%91%E6%8C%87%E5%8D%97/","excerpt":"我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持，才是胜利。加油！","text":"我们遇到什么困难也不要怕，微笑着面对它！消除恐惧的最好办法就是面对恐惧！坚持，才是胜利。加油！ 计算机体系结构1.冯诺依曼体系结构：由运算器 存储器 输入输出设备 控制器四个部分组成要点：计算机的数制采用二进制；计算机应该按照程序顺序进行。 2.量化设计基本原则1.大概率事件优先原则2.Amdahl定律3.程序的局部性原理4.CPU的性能 3.MIPS指令寻址方式和指令含义MIPS的数据寻址方式只有立即数寻址和偏移量寻址两种，I类指令、R类指令、J类指令。在MIPS中，控制流的改变是由一组跳转或一组分支指令来实现的。 4.流水线中的相关及产生原因1.结构相关：当指令在同步重叠执行过程中，硬件资源满足不了指令重叠执行的要求，发生资源冲突时将产生“结构相关”。2.数据相关：当一条指令需要用到前面指令的执行结果，而这些指令均在流水线中重叠执行时，就可能引起“数据相关”。3.控制相关：当流水线遇到分支指令和其他能够改变PC值的指令时就会发生“控制相关”。 5.分支目标缓冲要减少分支延迟，就要在指令阶段后期，知道在什么地址取下一条指令和可能的分支目标指令的地址。如果下一条指令是分支指令而且已知它的目标地址，则分支的开销可以降为零。将分支成功的分支指令的地址和它的分支目标地址都放到一个缓冲区中保存起来，缓存区以分支指令的地址作为标识；取指令阶段，所有指令地址都与保存的标识作比较，一旦相同，就认为本指令是分支指令，且认为它转移成功，并且它的分支目标地址就是保存在缓冲区中的分支目标地址。 6.Cache的平均访存时间计算及Cache性能提升的方法平均访存时间=命中时间+失效率×失效开销性能提升方法：减少失效开销，减少命中时间，降低失效率。 7.RAID0~RAIDRAID使用多个小容量磁盘代替一个大容量磁盘，能够有效改善磁盘的I/O性能，同时使磁盘容量扩充变简单。RAID0：采用数据分块技术，把数据分布在多个磁盘上，无冗余信息。 8.“网络”定义及对其传统计算机体系结构的冲击网络是由节点和连线构成，表示诸多对象及其相互联系。是信息传输、接收、共享的虚拟平台，实现信息共享。影响：将所有的部分都联系到一起。 基于冯诺依曼体系结构，论述基于CPU、存储器、I/O接口进行的计算机系统性能提升的技术研究，谈自己的看法。电脑的信息经过计算、处理、输出结果，而不是将数据同时输入电脑，这种串行方式延长了延长了数据输入和处理时间，限制了电脑的计算处理速度。CPU与外部设备、存储器的连接和数据交换都需要通过接口设备来实现，前者被称为I/O接口，后者被称为存储器接口。存储器通常在CPU的同步控制下工作。提升运算速度，需要执行的程序与需要处理的数据存放在主存中，内存的性能指标包括存储容量与存取速度。 微机原理1“权”与进制转换。进制转换是人们利用符号来计数的方法。进制转换由一组数码符号和两个基本“基数”与“位权”构成。基数是指进位计数制中的所采用的数码个数。位权是指进位制中每一固定位置对应单位值。 2数据存储与码制为了运算方便，带码符的机器数可采用原码、反码、补码、移码等不同的编码方式表示。这些编码方法被称为码制。各种数据在计算机内部的表示和存储形式称为机器数。特点：采用二进制，数的正负用0、1表示，小数点隐含表示二不占位置 3寻址方式寻址方式就是处理器根据指令中给出的地址信息来寻找有效地址的方式，是确定本条指令的数据地址以及下一条要执行的指令地址方式 4、8086扩展电路8086是16位微处理器。它的内部寄存器的主体是16位的，主要用于存放操作数的数据寄存器是16位的，主要作用地址指针的指针寄存器也是16位的。依赖分段机制，用20位段基地址加上16位的偏移量形成了20位的地址，以寻址IBM的物理地址。 5、I/O接口的数据传输CPU和外设之间通常传递的信息：数据、状态、控制。组成：寄存器组、控制逻辑电路、主机与接口和接口与I/O设备之间的信号连接线、数据地址线、控制状态信号线。数据传输方式：1.程序查询方式 2.程序中断方式 3.直接存储器（DMA）方式 6、中断系统中断装置和中断处理程序统称为中断系统。中断系统是计算机的重要组成部分。实时控制、故障自动处理、计算机与外围设备间的数据传送往往采用中断系统。中断系统的应用大大提高了计算机效率 2个64位二进制的加减运算 AREA example,CODE,READONLY ENTARY start mov r0,#1 mov r1,#0xffffffff mov r2,#1 mov r3,#0x2 adds r1,r2,r3 ;c位置1进位 r1 00000001 进一位 add r0,r0,r2 ;高位相加 得2 进1一位 得加上 所以r是0x00000003软件工程 软件危机的表现1.对软件开发成本和进度的估计常常很不正确 2.用户对已完成软件系统不满意 3.软件产品质量靠不住 4.软件常常不可维护 5.软件通常没有适当文档 6.软件成本提高 7.软件生产速度跟不上计算机普及深入趋势。 软件工程的定义软件工程是指导计算机软件开发和维护的一门工程学科 软件工程的基本原理1.用分阶段的生命周期计划严格管理 2.坚持进行阶段评审 3.实行严格的产品控制 4.采用现代程序设计技术 5.结果应能清楚地审查 6.开发小组的人员应该少而精 7.承认不断改进软件工程实践的必要 软件生命周期的定义以及阶段划分定义：软件的产生直到报废的生命周期阶段划分：1.问题定义 2.可行性研究 3.需求分析 4.总体设计 5.详细设计 6.编码和单元测试 7.综合测试 需求分析定义：通过分析，确定系统功能的过程任务：导出系统的逻辑模型 修正系统开发计划步骤：1.功能需求 2.性能需求 3.可靠性和可用性需求 4.出错处理需求 5.接口需求 6。约束 7. 逆向需求 8。将来可能提出的要求 总体设计任务：概况地说，系统应该如何实现步骤：1.设想供选择的方案 2.选取合理的方案 3.推荐最佳方案 4.功能分解 5.设计软件结构 6.设计数据库 7.制定测试计划 8.书写文档设计原理：耦合：对一个软件结构内不同模块之间互连程度的度量。内聚：模块内彼此结合的紧密程度衡量模块独立性的标准功能内聚 顺序内聚 通信内聚 过程内聚 时间/逻辑/偶然内聚 详细设计任务：设计出程序蓝图，以后程序员将根据这个蓝图写出实际的程序代码步骤：先创建设计模型，再用原型实现这个设计模型，并由用户试用和评估，然后根据用户意见修改 测试黑盒测试（知道功能） 白盒测试（知道产品内部工作过程）步骤：模块测试 子系统测试 系统测试 验收测试 平行运行","categories":[],"tags":[]},{"title":"samba共享服务器","slug":"samba共享服务器","date":"2019-12-25T16:36:52.000Z","updated":"2019-12-29T16:54:06.490Z","comments":true,"path":"2019/12/26/samba共享服务器/","link":"","permalink":"http://yoursite.com/2019/12/26/samba%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"Samba服务概述1.1 Samba概述Samba最先在Linux和Windows两个平台之间架起一座桥梁，可以因此在两个系统之间相互通信，比如拷贝文件、实现不同操作系统之间的资源共享等。可以将其架设为一个文件服务器或打印服务器提供本地和远程联机打印。","text":"Samba服务概述1.1 Samba概述Samba最先在Linux和Windows两个平台之间架起一座桥梁，可以因此在两个系统之间相互通信，比如拷贝文件、实现不同操作系统之间的资源共享等。可以将其架设为一个文件服务器或打印服务器提供本地和远程联机打印。 1.2 应用环境文件和打印机共享身份验证和权限设置名称解析浏览服务 端口号：139和445NETBIOS协议：网络基本输入/输出系统协议。协议，一般指用于局域网通信的一套API。主要作用：通过NETBIOS协议获得计算机名称，然后把计算机名解析为对应IP地址。 模式：C/S模式 检查安装Sambarpm -qa|grep samba如果出现以下显示，说明已经安装。samba-common-2.2.7a-7.9.0（CD1里）samba-client-2.2.7a-7.9.0samba-2.2.7a-7.9.0 redhat-config-samba-1.0.4-1(图形配置界面)samba-swat-2.2.7a-7.9.0（网页配置界面）如果没有安装，那么按照以下步骤：把第一张光盘放进光驱,他会自动挂接的,省得自己动手mount了 #cd /mnt/cdrom/RedHat/RPMS(注意大小写字母,否则会出错) #rpm -ivh samba-common-2.2.7a-7.9.0 (这个要先安装,安装的时候不一定要把后面的 samba-common-2.2.7a-7.9.0全部写完,比如写到samba-c的时候,多按几次Tab键,很省事的哦) #rpm -ivh samba-2.2.7a-7.9.0#rpm -ivh samba-client-2.2.7a-7.9.0(客户端)#rpm -ivh redhat-config-samba-1.0.4-1#rpm -ivh samba-swat-2.2.7a-7.9.0。在第三张光盘里注意要插入光盘，在VMware界面/虚拟机/可移动设备/CD/DVD/设置选择光盘 1.Samba的两个服务一个是smb，另一个是nmb； [root@localhost ~]# /etc/init.d/smb start启动 SMB 服务： [ 确定 ]启动 NMB 服务： [ 确定 ]如果停止呢？就在smb后面加stop ；重启就是restart[root@localhost ~]# /etc/init.d/smb stop[root@localhost ~]# /etc/init.d/smb restart 查看服务器是否运行起来了，则用下面的命令；[root@localhost ~]# pgrep smbd[root@localhost ~]# pgrep nmbd关掉Samba服务器，也可以用下面的办法，大多是通用的；要root权限来执行；[root@localhost ~]# pkill smbd[root@localhost ~]# pkill nmbd注意要关闭物理机的防火墙 实现匿名用户可读可写第一步： 更改smb.conf我们来实现一个最简单的功能，让所有用户可以读写一个Samba 服务器共享的一个文件夹；我们要改动一下smb.conf ；首先您要备份一下smb.conf文件；[root@localhost ~]# cd /etc/samba[root@localhost samba]# mv smb.conf smb.confBAK然后我们来重新创建一个smb.conf文件；[root@localhost samba]#touch smb.conf然后我们把下面这段写入smb.conf中；[global]workgroup = LinuxSirnetbios name = LinuxSir05server string = Linux Samba Server TestServersecurity = share [linuxsir] path = /opt/linuxsir writeable = yes browseable = yes guest ok = yes 注解：[global]这段是全局配置，是必段写的。其中有如下的几行；workgroup 就是Windows中显示的工作组；在这里我设置的是LINUXSIR （用大写）；netbios name 就是在Windows中显示出来的计算机名；server string 就是Samba服务器说明，可以自己来定义；这个不是什么重要的；security 这是验证和登录方式，这里我们用了share ；验证方式有好多种，这是其中一种；另外一种常用的是user的验证方式；如果用share呢，就是不用设置用户和密码了；[linuxsir] 这个在Windows中显示出来是共享的目录；path = 可以设置要共享的目录放在哪里；writeable 是否可写，这里我设置为可写；browseable 是否可以浏览，可以；可以浏览意味着，我们在工作组下能看到共享文件夹。如果您不想显示出来，那就设置为 browseable=noguest ok 匿名用户以guest身份是登录； 身份验证共享1.修改samba主配置文件smb.conf vim /etc/samba/smb.conf然后 passdb backend=smbpasswd smb passwd file =/etc/samba/smbpasswd 重启服务： service smb restart 查看目录自动穿件了smbpasswd文件 ls /etc/samba/ 添加用户和组并添加相应的samba账号使用groupadd命令添加xsb组，然后执行useradd命令和passwd命令添加销售部员工账号密码 groupadd xsb useradd -g xsb xsb01 useradd -g xsb xsb02 id xsb01创建共享目录， mkdir /xsb cp /etc/hosts /xsb/修改配置文件，制定目录共享，设置权限 vim /etc/samba/smb.conf[xsb]//设置共享目录的共享名comment = xsb datapath =/xsb//设置共享目录的绝对路径valid users =@xsb//设置允许访问的用户为xsb组内的用户 service smb restart 然后可以访问虚拟机ip地址 192.168.42.2我的主机地址是 192.168.42.1主机win+R 然后输入ipconfig查询主机IP地址虚拟机打开终端输入 ifconfig -a 查询虚拟机IP","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"关于2019","slug":"关于2019","date":"2019-12-20T16:07:35.000Z","updated":"2019-12-21T10:34:57.673Z","comments":true,"path":"2019/12/21/关于2019/","link":"","permalink":"http://yoursite.com/2019/12/21/%E5%85%B3%E4%BA%8E2019/","excerpt":"此时已莺飞草长，爱的人正在路上。 时间过得真快，年初的那一场大雪还历历在目，现在都到年底了。今年又是充实而有趣碌碌而无为的一年，继续加油吧。- 生活- 学习- 随笔- 心理- 畅想","text":"此时已莺飞草长，爱的人正在路上。 时间过得真快，年初的那一场大雪还历历在目，现在都到年底了。今年又是充实而有趣碌碌而无为的一年，继续加油吧。- 生活- 学习- 随笔- 心理- 畅想 生活篇----------------------------------------------------------大三上学期到办了健身卡，去的次数也不是特别多，但对我的帮助挺大的。并不是说因此身材变得多好，而是通过健身使得自己在饮食、休息方面注意了很多。比如以前经常昼夜颠倒不吃早餐喜欢吃宵夜，现在改善了不少。主要是观念发生了变化吧，以前一直信奉“今朝有酒今朝醉”的及时享乐主义，然后导致体魄不是很好。我想自律些也挺好的，就像减脂这件事也并不一定是为了瘦下来多好看，更重要的是身体更健康吧，要是年纪轻轻身体素质不好甚至高血压多难受啊（顺便一提上动感单车课真的很棒）。而且健身就不至于总待在宿舍，多出去走走呼吸下新鲜空气也是好的。希望自己十年二十年后也有好的身体吧。 今年才算是认认真真地学习做菜，主要是为了以后不至于只能点外卖或者吃泡面吧，而且外边很多餐厅和我的个人习惯不是很符合。最近学的都是素菜，暑假在家的时候也有看一些视频研究怎么做好吃，哈哈买家秀和卖家秀的区别还是挺大的。偶尔听到有人夸我厨艺的时候还是蛮开心的。 学习篇 对于未来发展与职业规划大致有了方向。虽然现在还是很菜，但相比于迷茫的大一大二，当前状态明显好了很多。大学多好啊，希望自己能够珍惜当下。大三没有参加什么社团或学院活动了，打算多花时间在专业知识学习上。哈哈其实以前参加这些也只是为了加点儿综测分，但参与一些有意义的活动还是还是不错的。 随笔篇----------------------------------------------------------今年去了挺多地方的，有计划过一个人的旅行，结果都是一群人的狂欢。我很喜欢了解一个城市的风土人情和历史沿革。历史真的很神奇，在知道一些历史往事后再去看这座城市往往体会的更多。在看兵马俑时想到秦始皇用陕西话发号施令就觉得很有趣哈哈，七月份的时候去了趟广州和深圳，初见挺喜欢的，如果以后在这两座城市打拼或许也不错。 可能是性子温和，一直嘻嘻哈哈表现的很开朗，认识了挺多朋友，很庆幸这一点，最高兴的是至今和认识很多年的好友保持联系。其实更多时候我会喜欢独处些。很喜欢周国平先生说的“我天性不宜交际。在多数场合，我不是觉得对方乏味，就是害怕对方觉得我乏味。可是我既不愿忍受对方的乏味，也不愿费劲使自己显得有趣，那都太累了。我独处时最轻松，因为我不觉得自己乏味，即使乏味，也自己承受，不累及他人，无需感到不安。”在这样的话中我找到了共鸣。当然，和朋友相处也是很不错的鸭！ 今年看了好多电影，我印象最深的是动漫电影吧，从19年初的《白蛇缘起》到《哪吒》国漫之光照耀哇！还有《冰雪奇缘》也非常棒，哈哈好像是挺喜欢动漫电影，因为更喜欢喜剧结尾。当然《少年的你》也很精彩啊，不过看完挺压抑的。我觉得看电影是要从千千万万个故事里面读懂千千万万个情感，看电影用倍速看特别不好，感到枯燥体会不到电影的情感大可不必看（所以筛选环境很重要！）。 心理篇---------------------------------------------------------- 你要做一个不动声色的大人了 不准情绪化 不准偷偷想念 不准回头看 去过自己另外的生活 你要听话 不是所有的鱼都生活在同一片海里 对感情是抱有期待的，有时候会觉得孤独吧，也希望有人可以沟通，有人可以分享。其实我对于感情是保持悲观态度的。我是个自私的人，在理性上不愿把自己的感情投入到别人身上。可能是自己独立久了会不习惯？自己不愿付出太多？或者是不懂两个人的快乐吧。我也不着急改变什么。看得原来越开，过去做错了什么，错过了什么都不再耿耿于怀，错过也不可惜，尝试着与自己和解，吃亏也趁早吧，人要往前看嘛。不过如果谈了恋爱就对女孩儿好一点。毕竟20岁是男生的人生低谷，除了身体素质，其他无论见识气度还是情商财力都很弱。我好像吃过很多人的瓜，见过很多人的爱恨纠葛，都是别人的故事。其实每个人都有故事啦，不过我的很少。如果遇见一个人，可以把“我走过的四下无人的街，和我度过的烂醉如泥的夜”分享给彼此或许非常不错。 想要增加一些人生体验吧，去旅行，做义工，哪怕不能经历看看电影也是好的。以前总是迁就别人，担心自己哪里做错了，越来越觉得没必要这样。爱自己才是终生浪漫的开始嘛。有朋友说自己越来越没有耐心，别人真心分享的很多东西也不能用心看完。可是人的经历各不相同，人的悲欢也并不相通。自己的感受才是最重要的。 我觉得今年是要比去年成长了些的。有了许多自己的想法，三观应该也正了很多。学会辨别别人的说法，学会理解别人的思想，人和人是不同的，认识到不同后又要怎么处理这些不同都需要思考。有时候会审视他人，自己的同理心就消失了。而审视自己的时候，往往只会得到一个结论：SB。这都不好，以后要从更多个角度看待问题吧。 最重要的一点：可以的话多陪陪多关心家人！ 2020畅想篇----------------------------------------------------------希望2020的我觉得19年的自己是傻逼(最好少做傻事)，其实如果每年的自己都觉得去年的自己是傻逼也好吧，至少说明自己有进步了。 最重要的当然是学习啊，因为不准备考研了然后20年应该会开始实习，希望能在实习工作中顺利。 明年有明年的雪 明年的雾色 明年的永无止休的阳光 还有明年数不尽的生机","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Makedown语法总结","slug":"Makedown语法总结","date":"2019-12-16T13:29:19.000Z","updated":"2019-12-20T15:01:25.646Z","comments":true,"path":"2019/12/16/Makedown语法总结/","link":"","permalink":"http://yoursite.com/2019/12/16/Makedown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"这里主要讲十二种Makedown语法的使用(内赠我的壁纸一张~) 标题 文字修饰符 分隔符 列表 插入引用 引用 行内代码 表格 流程图 删除线 待办事宜 Todo 列表 内容目录","text":"这里主要讲十二种Makedown语法的使用(内赠我的壁纸一张~) 标题 文字修饰符 分隔符 列表 插入引用 引用 行内代码 表格 流程图 删除线 待办事宜 Todo 列表 内容目录 1.标题行首插入 1 到 6 个 # ，#和标题文字之间使用一个或多个空格，对应到标题 1 到 6 级，例如：一级标题二级标题三级标题四级标题五级标题六级标题 2.文字修饰符粗体修饰举例: **陌上花开，可缓缓归矣 **例子：陌上花开，可缓缓归矣斜体： *陌上花开，可缓缓归矣*例子：陌上花开，可缓缓归矣 3.分隔符Hello world! ---------------------------------------------------------- Very good!最终显示：Hello world! Very good! 4.列表列表分为两种：无序列表和有序列表无序列表： (切记序号与文本之间存在一个空格) - Five Hundred Miles - Right Here Waiting - Long Long Journey最终显示(切记序号与文本之间存在一个空格) Five Hundred Miles Right Here Waiting Long Long Journey有序列表(切记序号与文本之间存在一个空格) Five Hundred Miles 1 Right Here Waiting 2 Long Long Journey 2 Only Time最终显示(切记序号与文本之间存在一个空格) Five Hundred Miles 1.1 Right Here Waiting 1.2 Long Long Journey 2.2 Only Time 5.插入引用插入链接举例： [显示文本](链接地址)小庄的博客主页插入图片也一样： ![显示文本](图片链接地址)真好看，不愧是我的壁纸~ 对了推荐一个图床，可以把图片上传到这个网站，然后获得外部链接，使用Markdown语法就可以完成图片的插入了。完美解决图片占据大量的存储的空间，加载相对缓慢的问题.很方便是不是= = 6.引用&gt; I will be right here waiting for you.最终显示 I will be right here waiting for you. 7.行内代码代码引用 &apos;Hello World&apos;显示：Hello World 多段代码引用 显示：```Hello World!Hello World!!Hello World!!!``` 12345(```) 代码... 代码... 代码...(```) 8.表格表格形成（使用|划分列，|—-|表示默认对齐，|—:|表示右对齐，|:–:|表示居中对齐，|:—-|） 姓名 性别 手机号 微信号 默认 右对齐 左对齐 居中 庄杰 男 150XXXX 973XXX 9.流程图12345678st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;效果flow st=&gt;start: 开始 op=&gt;operation: My Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op &amp; 10.删除线这是删除线这是删除线 11.待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表 [] 吃饭 [] 睡觉 [] 打游戏 学习 12. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 暂时就这么多啦，Makedown还是很好用的。简洁明了又容易掌握，功能也比纯文本强。相对于html而言算是轻量级语言了，而且完美兼容html，可以在文章中直接插入html代码 非常棒！网上也有很多编辑器可以用，比如vscode、MarkPad，我没用过就不评论了，我用的编辑器是Typora，个人感觉很不错。 一点点建议 指令无须强记，用多了自然就熟练 如果有不懂的就查看Markdown语法手册 网址是这个","categories":[],"tags":[{"name":"学习 Markdown","slug":"学习-Markdown","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0-Markdown/"}]},{"title":"javaSE进阶","slug":"javaSE进阶","date":"2019-12-10T15:51:18.576Z","updated":"2020-02-05T14:40:24.848Z","comments":true,"path":"2019/12/10/javaSE进阶/","link":"","permalink":"http://yoursite.com/2019/12/10/javaSE%E8%BF%9B%E9%98%B6/","excerpt":"title: javaSE进阶date: 2019-12-10 23:51:18tags: javacategories: java #### 接口作用 1.可以使项目分层，所有层都面向接口开发，提高效率 2.降低代码间的耦合度。 3.接口可多实现、多继承 public interface customerService{ //定义一个退出系统的方法 void logout(); }","text":"title: javaSE进阶date: 2019-12-10 23:51:18tags: javacategories: java #### 接口作用 1.可以使项目分层，所有层都面向接口开发，提高效率 2.降低代码间的耦合度。 3.接口可多实现、多继承 public interface customerService{ //定义一个退出系统的方法 void logout(); } #### 静态内部类(static) 可以等同看做静态变量 内部类重要的作用：可以访问外部类中似有的数据 #### 成员内部类 可以等同看做成员变量 不能有静态声明(static) #### 局部内部类 等同于局部变量 **局部内部类在访问局部变量时，局部变量必须使用final修饰** int i = 10; #### 匿名内部类 #### 类和类之间的关系 - 泛化关系：类和类之间的继承关系及接口与接口之间的继承关系 - 实现关系：类对接口的实现。 - 关联关系：类与类之间的连接 - 聚合关系：是关联关系的一种，整体和部分的关系，比如汽车和轮胎。 - 合成关系：合成关系和聚合关系类似，区别在于 整体整体和部分是紧密相连的，整体的生命周期决定部分生命周期，比如人和大脑。 - 依赖关系 异常机制1.异常是什么 异常模拟的是现实世界中“不正常”事件java中采用“类”模拟异常类是可以创建对象的。 2.异常机制的作用java为我们提供一种完善的异常处理机制作用：程序发生异常事件后，为我们输出详细的信息，程序员通过这个信息，可以对程序进行一些处理，使程序更加健壮。 如何处理异常- 声明抛出 throwsthrows并不是处理异常，只是向上抛（类似推卸责任），谁让执行就抛给谁，如果一直抛到最高层就会抛给JVM虚拟机，然后不执行。 - 捕捉 try…catch真正处理。 getMessage和printStackTrace方法关于finally语句块1.finally语句块可以直接和try语句块连用。try...finally... 2.try...catch...finally..也可 3.在finally语句块中的代码一定会执行自定义异常自定义“无效名异常”1.编译时异常，直接继承Exception2.运行时异常，直接继承RuntimeException想让外部知道异常就用throws，不想让知道就自己用try..out解决 public class IllegalNameException extends Exception{//编译时异常 //pubilc class IllegalNameException extends RuntimeException//运行时异常 //定义异常一般提供两个构造方法 pubilic IllegalNameException(){} public IllegalNamneException(String massage){ super(massage); } } 定义好注册 public class CustomerService throws IllegalNameException{ //完成注册 if(name.length()&lt;6){ //异常 //创建异常对象 //IllegalNameException e=new IllegalNameException(“用户名长度不能少于六位”); //手动抛出异常 既然是手动抛出就不要自己用try..out解决了，如果想让外部知道异常了就不要用try…out //throw e;//这里是throw不是throws，最前面代码才是throws //前边两行代码连起来为 throw new IllegalNameException(“用户名长度不能少于6位”)； } //如果代码执行到这，证明用户名合法 }测试程序 public class Test{ public static void main(String[] args){ //假如用户提供的用户名如下 String username=”jack” //注册 CustomerService cs=new CustomerService(); try{//这里如果用throws下面的代码就不能执行了。 cs.regiater(username); }catch(IllegalNameException e){ Systom.out.println(e.getMessage()); } } } 方法的覆盖与异常重写的方法不能比被重写的方法抛出更宽泛的异常 一维数组1.数组是一种引用类型 2.数组是一种简单的数据结构 3.数组是一个容器，可以用来存储其他元素 4.数组分为一维数组，二维数组，三维数组，多维数组 5.数组一旦创建，长度不可改变 //声明一个一维数组，用来存储byte类型 byte[] a1=(1,2,3,4); //存储char数组 char[]b1=(&apos;a&apos;,&apos;b,&apos;c&apos;); //静态初始化一个int类型的一维数组 int[] a1={10,20,30}; //取得第一个元素 System.out.println(&quot;第一个元素:&quot;+a1[0]); System.out.println(&quot;第二个元素:&quot;+a1[1]); System.out.println(&quot;第三个元素:&quot;+a1[2]); //遍历一维数组 for(int i=0;i&lt;a1.length;i++){ system.out.println(a1[i]); }//动态声明一个int类型的数组，最多可以存储4个元素int[] a1=new int[4]; 关于main方法中String[] argsString[] args是专门用来接收命令行参数的 数组的拷贝int[] src ={2,3,4,5,6,7}; int[] dest={10,11,12,13,14,15,16}; //吧src中的4,5,6拷贝到dest数组从13开始 //System.arraycopy(数源组,源数据的开始下标,目标数组,目标数组的开始下标,拷贝的长度。); System.arraycopy(src,2,dest,3,3); //遍历 for(int i=0;i&lt;dest.length;i++){ System.out.println(dest[i]); }二维数组1.二维数组是特殊的一维数组 2.特殊在这个一维数组中每个元素都是“一维数组” //静态初始化二维数组 int[][] a={ {1,2,3}, {45,34}, {0}. {10,23,85,99} }; //以上这个数组有多少个一维数组 System.out.println(a.length+&quot;个一维数组&quot;); //获取一个一维数组 int[] a0=a[0];**//代表第一个int数组** int a00=a0[0];**//一维数组第一个元素** System.out.println(a00); //获取第一个一维数组的第一个元素 System.out.println(a[0]a[0]; //获取第二个一维数组的第一个元素 System.out.println(a[1][0]); //遍历二维数组 //纵向循环在外 for(int i=0;i&lt;a.length;i++){ //对一维数组a[i]进行遍历 for(int j=0;j&lt;a[i].length;j++){ System.out.println(a[i][j]+&quot;&quot;); } System.out.println(); }冒泡排序算法package SElianxi;public class A { public static void main (String[] args){ int[] a ={3,1,6,2,5}; //开始排序 for(int i=a.length-1;i&gt;0;i–){ for(int j=0;j&lt;i;j++){ if(a[j]&gt;a[j+1]){ //交换位置 int temp; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } } //遍历 for(int i=0;i&lt;a.length;i++){ System.out.print(a[i]); } }} 二分法 binarySearch(a,10) //从a数组找10Integer int String三种类型相互转换int→Intager //基本数据类型→引用类型 pubulic class A{} public static void main(String[] args){ //1.int→Intager Integer i1= Integer.valueOf(10)； //2.Integer→int int i2 =i1.vatValue(); //3.String--&gt;Integer Integer i3 =Integer.valueOf(&quot;10&quot;); //4.Integer--&gt;int String s1=i3.toString(); //5.String--&gt;int int i4=Integer.parseInt(&quot;123&quot;); //6.int--&gt;string String s2=10+&quot;&quot;; } }","categories":[],"tags":[]},{"title":"java基础","slug":"java基础","date":"2019-11-18T23:39:08.000Z","updated":"2019-12-20T08:28:56.186Z","comments":true,"path":"2019/11/19/java基础/","link":"","permalink":"http://yoursite.com/2019/11/19/java%E5%9F%BA%E7%A1%80/","excerpt":"# 定义Java中的方法 ## 定义一个方法的语法是： 访问修饰符 返回值类型 方法名(参数列表){ 方法体 } 比如: public void print(){ Systtem.out.println(\"\") } 什么是类和对象比如像买个手机，比如三星、苹果、华为就是对象，手机有屏幕5.8寸、cpu8核（有特定值）就 是方法。手机可以打电话发短信就是方法。类是抽象的，用来描述信息。对象是具体的。 public class 类名{ //定义属性部分（成员变量） 属性 有什么 //定义方法部分 方法 干什么}","text":"# 定义Java中的方法 ## 定义一个方法的语法是： 访问修饰符 返回值类型 方法名(参数列表){ 方法体 } 比如: public void print(){ Systtem.out.println(\"\") } 什么是类和对象比如像买个手机，比如三星、苹果、华为就是对象，手机有屏幕5.8寸、cpu8核（有特定值）就 是方法。手机可以打电话发短信就是方法。类是抽象的，用来描述信息。对象是具体的。 public class 类名{ //定义属性部分（成员变量） 属性 有什么 //定义方法部分 方法 干什么} 使用对象的步骤1.创建对象类名 对象名=new 类名();2.使用对象引用对象的属性：对象名.属性phone.screen=5;//给screen属性赋值5 成员变量和局部变量作用域不同 局部变量的作用域仅限于定义它的方法 成员变量的作用域在整个类的内部都可见初始值不同，成员变量有初始值，局部变量无同一方法不允许有同名局部变量，不同方法可以有重名时局部变量优先调用 构造方法封装什么是封装 概念 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。 好处 1.只能通过规定的方法访问数据 2.隐藏类的实例细节，方便修改和实现 封装的实现步骤 修改属性的可见性(设为private)—创建getter/setter方法（用于属性的读写）—在getter/setter方法中加入属性控制语句(对属性值的合法性进行判断)访问修饰符private 只能本类使用默认 本类/同包可用protected 本类/同包/子类可用public 所有都可用 switch只能用int或string类型，其他类型需要转换，比如:long x=100L;switch((int)x){ case””: System.out.println(1); break;} 关于java中的static关键字1.static翻译为静态的 2.static修饰的方法是静态方法 3.static修饰的变量是静态变量 4.所有static修饰的元素都称为静态的，都可以使用&quot;类名.&quot;的方式访问，也可引用.的方式访问(不建议) 5.static修饰的所有元素都是类级别的特征，和具体对象无关继承1.基本作用：代码复用，有了继承才有“方法的覆盖”“多态机制” 2.继承语法格式： 3.[修饰符列表] class 类名 extends 父类名{ 类体=属性+方法 } 4.java语言假设一个类没有显示的继承任何类，该类默认继承JavaSE库当中提供的java，lang.Object类。多态父类变子类，子类变父类= =降低耦合度，提高程序扩展力。核心！面向抽象编程，不要面向具体编程！！！避免向下转型出现的classCastException：使用instanceof运算符。 java语言基础主要包括：*标识符 *关键字 *字面值 *变量 *数据类型 *运算符 *控制语句 *方法 *递归总结内容*面向对象和面向过程的区别 *面向对象三大特征 *OOA OOD OOP *类和对象的概念 *类的定义 *对象的创建和使用 *JVM内存管理 *参数传递 *封装 *继承 *多态 *this关键字 *static关键字 *final关键字 *访问控制权限修饰符 *构造函数 *方法的重写/覆盖 package和import","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"学习 java","slug":"学习-java","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0-java/"}]},{"title":"关于js部分内容","slug":"关于js部分内容","date":"2019-11-11T18:26:56.000Z","updated":"2019-12-20T08:28:47.915Z","comments":true,"path":"2019/11/12/关于js部分内容/","link":"","permalink":"http://yoursite.com/2019/11/12/%E5%85%B3%E4%BA%8Ejs%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9/","excerpt":"# 这是近期学习js总结 ## 1.让图片自适应框的大小 ### 知识点 先获取div框的高度和宽度div.offsetWidthdiv.offsetHeight 重新设定图片的高度和宽度Image.WidthImage.height","text":"# 这是近期学习js总结 ## 1.让图片自适应框的大小 ### 知识点 先获取div框的高度和宽度div.offsetWidthdiv.offsetHeight 重新设定图片的高度和宽度Image.WidthImage.height window.onload =function(){ var img1 =document.getElementById(\"id-img1\"); adjsutImgFitDiv(img1); var img2 =document.getElementById(\"id-img2\") adjsutImgFitDiv(img2); }; function adjsutImgFitDiv(img){ var div =img.parentNode; var w=div.offsetWidth; var h=div.offsetHeight; img.width=w - 2; img.height= h - 2; } 2、为图片加边框知识点：Image.style.border = “ 1px solid red ” ; /* 边框颜色 */ function on_sel_color_changed(thisid){ var selColor =document.getElementById(thisid); var color=selColor.value; var selWidth=document.getElementById(\"id-sel-width\"); var width=selWidth.value; setImageBorder(width,color); } /*边框厚度*/ function on_sel_width_changed(thisid){ var selwidth=document.getElementById(thisid); var width=selwidth.value; var selColor=document.getElementById(\"id-sel-color\"); var color=selColor.value; setImageBorder(width,color); } /*图片上加边框*/ function setImageBorder(width,color){ var img=document.getElementById(\"id-img\"); if(width==\"0\"||color==\"none\"){ img.style.border=\"\"; }else{ img.style.border=width+\"px solid\"+color; } } 3、显示局部图片 知识点 每一张图片在HTML页面窗口中都是由定位尺寸的，通过对该定位尺寸进行变换计算，就可以选取图片的某一个局部 ，并在 页面中进行显示。Image.style.backgroundPosition= x坐标 y坐标 ;4、动态加载图片知识点 自定义属性：自己定义的 lazy_src&lt;img lazy_src=”images/js-dyn-load.jpg“src=”” alt=”图片未加载” id=”id-img”/&gt; 点击按钮时，把自定义属性，赋值给src，用于显示图片的路径Image.src = image.attributes[‘lazy_src’].value;5延迟加载图片知识点 时间间隔是：等待3000毫秒，显示图片计时器：setTimeOut(function() {} , 3000);setInterval是循环计时，而setTimeOut是定时一次 6、重新加载验证码图片知识点 自定义属性改变图片的路径，然后把自定义的路径 赋值给 srcimg.src = img.attributes[‘lazy_src_’ + index.toString()].value;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"next主题配置过程(持续更新)","slug":"next主题配置过程","date":"2019-11-11T14:55:45.000Z","updated":"2019-12-06T11:35:12.840Z","comments":true,"path":"2019/11/11/next主题配置过程/","link":"","permalink":"http://yoursite.com/2019/11/11/next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/","excerpt":"经过一番折腾我们终于搭建好了个人博客，本文来讨论next主题的设置 1、基本信息配置打开站点配置文件_config.yml，找到Site模块title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写）","text":"经过一番折腾我们终于搭建好了个人博客，本文来讨论next主题的设置 1、基本信息配置打开站点配置文件_config.yml，找到Site模块title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 2、菜单设置菜单包括：首页、归档、分类、标签、关于等我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 主题配置文件 找到Menu Settingsmenu: home: / || home //首页 archives: /archives/||archive //归档 categories: /categories/||th //分类 tags: /tags/||tags //标签 about: /about/||user //关于 #schedule: /schedule/||calendar //日程表 #sitemap: /sitemap.xml||sitemap //站点地图 #commonweal: /404/||heartbeat //公益404需要哪个菜单就把那个取消注释打开就行。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-11-03T08:59:35.937Z","updated":"2019-11-03T08:59:35.937Z","comments":true,"path":"2019/11/03/hello-world/","link":"","permalink":"http://yoursite.com/2019/11/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}